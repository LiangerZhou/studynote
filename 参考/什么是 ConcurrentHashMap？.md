> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192083&idx=1&sn=5c4becd5724dd72ad489b9ed466329f5&chksm=8c990d49bbee845f69345e4121888ec967df27988bc66afd984a25331d2f6464a61dc0335a54&scene=21#wechat_redirect

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibFeOCfzdgCSGxCwk7rpShgibpEb2ZJiaSYvcjqzedaEIUzk0EAjX0lcrw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibcNx6aZNgs2vpvx2G7raGjSZWicBJiclTmSII7ZRxJMSwTkrDCJF0JTUQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibPVwIB5gQXFiagia5msqboudyO2xfUrVWSNic5J5eM2sHGnNKPgshJzwhg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibqJYIftl7LrZfuHcziapAiavgefibj69bEx4ib5wrehElwEhwYQthRJbUlQ/0?wx_fmt=jpeg)

————————————

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKt0RC8QnoOahl9MSGG01mQk35laaRwmIT4A8IWHnmFFy7vKNicXoJDGibA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKtSKFImWLnRGUNI1Ct4FRoC8ZsX0wflMBqEjJqFdof43317OiaGicydjkA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BxyfO1KEQ6toqFjc1aXzcyYCxRM3hD7vKn2nBS8r4zUVCk7W8ibvt6aA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibiads356xN0taFqKibwQswt2yhHvHQ1Pz3JMiaJziakxALXicibhzv5JDZyvw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicib1ur05WyBsbJgC0zbG2icKtIO8n6PvqcNYDzUa68UzvfhQNssAnS1V8Q/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRliciblIVBAEOBicBS9iauy3VZabXDntDM33Q1AtDF3ODnOKYQAx2RqNmUf5gQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibpdECmIZ67tA0yxavxMywGtdrORXpYflK9lfVUDoP9ToIpJlTlPEbZw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRliciblf0FKgd5WHkVLrvDficaou6Rx64PicvGIIGkI4uRvKT5JSNia7mno8ZXw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibria28hcMaYsD6PAU4kadxibBibLkn7liajruuKsrQYMv8R9iaKG35dWeFxw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKt7QQYlx0RBp6ULicOLk7VDgklBY78dV1WD2w2VLhR7gACzdpHPgNmWZQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibKiaYWBVD95t9eMPD38BqeaMTocfQiaBFsBB9ne4LUS56H94vh4X1w3HQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibeA2U7T7czU2byS3xXGRsqK0cWlFrLpXSYMC4YcFdkrUTP4KJoz4OLw/0?wx_fmt=jpeg)

————————————

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibTmibRE4WKiaZvG09D93pHia9qFR2VBo0ljIicRBFEfFoBeHX4Tthp2Me8w/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibMEfmqYIAlw8gteyMly7IMic1fjNiaQBJHGkZg8WepSgNuGMNActD2zZA/0?wx_fmt=jpeg)

前两期我们讲解了 HashMap 的基本原理，以及高并发场景下存在的问题。没看过的小伙伴可以点击下面链接：

[漫画：什么是 HashMap？](http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=21#wechat_redirect)  

[漫画：高并发下的 HashMap](http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192000&idx=1&sn=118cee6d1c67e7b8e4f762af3e61643e&chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&scene=21#wechat_redirect)  

如果实在懒得看也没有关系，我们来简单回顾一下 HashMap 的结构：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRliciblRTjqsJxRV2TeFUsdRlnDZwzX0RJbvibUSzJ0gd80PqI0S833PxSDIw/0?wx_fmt=png)

简单来说，HashMap 是一个 Entry 对象的数组。数组中的每一个 Entry 元素，又是一个链表的头节点。

Hashmap 不是线程安全的。在高并发环境下做插入操作，有可能出现下面的环形链表：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibP5nR8dWN0PqWGKJyicFNBfz9nyeWA1HYPx8MZiaibvibonZoiay8FQO9KjA/0?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibj44SDpx87ojIfYuOLDQITZ6bL2JBAe8KukHkObrkgLtHmH3JZpoyWA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibs86wVicuFn3NoVRorcgkOEQcO7X8j8qwDUu3iaws0ibVHW6CFQMHPayibw/0?wx_fmt=jpeg)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibNvoVBUEEpdJg6ehHJxuCwjHZggLVBxZ5HEErDHVv7utElg8aibnUKww/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibHxQhXUiaVUSFYwoUiaHUmGnzEQ6aqKtEmEBJwmq28F0sa5ZDDxqGfzFQ/0?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibWZZ2nZ2vZA2EJS9iaylXjkHAtQOnb897EejEf6mD1icTJ1ZsibcDkWib1A/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicib1r4X75UBNShRic1EZ8lQNq9FvYuh74xjsUPxBGjCUzdrbtgqK8mfQng/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicib23PRQs9XUvdFVNUkcoeVgeNqF4svJ7ibZGX6kutA90XyD2ribarSLyyg/0?wx_fmt=jpeg)

Segment 是什么呢？Segment 本身就相当于一个 HashMap 对象。

同 HashMap 一样，Segment 包含一个 HashEntry 数组，数组中的每一个 HashEntry 既是一个键值对，也是一个链表的头节点。

单一的 Segment 结构如下：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibECSPCngB5ZTUM5CDtia82bWSpoQyYZX5IdB4cgWZzFAU0ibR1kMY3aYQ/0?wx_fmt=png)

像这样的 Segment 对象，在 ConcurrentHashMap 集合中有多少个呢？有 2 的 N 次方个，共同保存在一个名为 segments 的数组当中。

因此整个 ConcurrentHashMap 的结构如下：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibic8zsZTl3rP40ETlt2PPb66Qib0MflicQn0icbuPgl8icxnEqpsuMWstaUA/0?wx_fmt=png)

可以说，ConcurrentHashMap 是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。

这样的二级结构，和数据库的水平拆分有些相似。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibLKRJFe0pHGaVWvShlBBJjgPp7a3tV6h7LJkweyqvflvC4MJF4LkHAA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibUT9DwyDUNdAC7fHJhQ9ZgAqvkMJEIlCeObMAibkdgBtiapJS0RIzdfrA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicib9RZb5gN5nvJGrL0LCHl1EzOkfGS5vcCkramKdMuSdKdNxu9WARqibRg/0?wx_fmt=jpeg)

**Case1：不同 Segment 的并发写入**

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRliciboY9ZAIGibC0RdVyeNJpgbuf2YujcFXU9g4tWynozm3GlBXYAcTJeicGA/0?wx_fmt=png)

不同 Segment 的写入是可以并发执行的。

**Case2：同一 Segment 的一写一读**

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibPaiaUCvleib1tXvVNCOu4ia2CNfzgwoIBrl3Oml2bQ7pWHxumoqBMWuFg/0?wx_fmt=png)

同一 Segment 的写和读是可以并发执行的。

**Case3：同一 Segment 的并发写入**

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibjgkJZN4Q7CT2icrdRV4e7BnA36ic5RHGkh7KnU7cxJr3NRWSRRXcYdpQ/0?wx_fmt=png)

Segment 的写入是需要上锁的，因此对同一 Segment 的并发写入会被阻塞。

由此可见，ConcurrentHashMap 当中每个 Segment 各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibG9kAiafQuf3Pic110oCyOU2MzSEmhOuu61kgTDWJ9b9qKJ98iakRTA1vw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibFFJWhcQKYlia41b0JQCTY6zmWKzoBypNnqgC19ldnEkicIftLcT6Lj9Q/0?wx_fmt=jpeg)

**Get 方法：**

1. 为输入的 Key 做 Hash 运算，得到 hash 值。

2. 通过 hash 值，定位到对应的 Segment 对象

3. 再次通过 hash 值，定位到 Segment 当中数组的具体位置。

**Put 方法：**

1. 为输入的 Key 做 Hash 运算，得到 hash 值。

2. 通过 hash 值，定位到对应的 Segment 对象

3. 获取可重入锁

4. 再次通过 hash 值，定位到 Segment 当中数组的具体位置。

5. 插入或覆盖 HashEntry 对象。

6. 释放锁。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrHK9nK9txBUABzboEVaSlYJA1cbzOgUN0F1U4HfKpd9fb6ciaSpnyVEHEVU6NagGSgicMQ6e73XgIA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibrOBf4QbSUKRUfBnNEg5nY4Uu0SbmFlAQo9licTd0Xd02OaEHXuibtI9Q/0?wx_fmt=jpeg)

Size 方法的目的是统计 ConcurrentHashMap 的总元素数量， 自然需要把各个 Segment 内部的元素数量汇总起来。

但是，如果在统计 Segment 元素数量的过程中，已统计过的 Segment 瞬间插入新的元素，这时候该怎么办呢？

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibofZicDlWnFFkV2km0uFrVlRicQZvSWdnFjfR9Ur8ziadwUwNHCgXEelog/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibYlJ3InAcQ80wLjeXhAPVJpY0SPmm5H5lUR0chPjDQcFjqdOGeSj14A/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibUN2XbPADFdAgbicR0HUXyUwraiat5na9WkPQicuWFlJeZSFgkLyPM31rw/0?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicibHJjB6iatp0oQ1oiaWoYTB8LBChsI5NA7rm9RLTSAqnwkI8KySBmemuiaQ/0?wx_fmt=jpeg)

ConcurrentHashMap 的 Size 方法是一个嵌套循环，大体逻辑如下：

1. 遍历所有的 Segment。

2. 把 Segment 的元素数量累加起来。  

3. 把 Segment 的修改次数累加起来。  

4. 判断所有 Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数 + 1；如果不是。说明没有修改，统计结束。

5. 如果尝试次数超过阈值，则对每一个 Segment 加锁，再重新统计。

6. 再次判断所有 Segment 的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。

7. 释放锁，统计结束。

官方源代码如下：

```
public int size() {
    // Try a few times to get accurate count. On failure due to
   // continuous async changes in table, resort to locking.
   final Segment<K,V>[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}

```

为什么这样设计呢？这种思想和乐观锁悲观锁的思想如出一辙。

为了尽量不锁住所有 Segment，首先乐观地假设 Size 过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有 Segment 保证强一致性。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq3vUVmwkicuamaVhB9uRlicib8kbU1ialfE0k1RV8bicfxufJicicUHID203ZjZHhkbaHV9Pb0YQnxRJHOg/0?wx_fmt=jpeg)

**几点说明：**

1. 这里介绍的 ConcurrentHashMap 原理和代码，都是基于 Java1.7 的。在 Java8 中会有些许差别。

2.ConcurrentHashMap 在对 Key 求 Hash 值的时候，为了实现 Segment 均匀分布，进行了两次 Hash。有兴趣的朋友可以研究一下源代码。

—————END—————