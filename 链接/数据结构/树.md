
# 树

## 1. 树的简介

### 1.1 树的基础

树是一种数据结构，它是 n(n>=0) 个节点的有限集。n=0 时称为空树。n>0 时，有限集的元素构成一个具有层次感的数据结构。  
![https://images2015.cnblogs.com/blog/610439/201601/610439-20160129122953958-738559067.png](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129122953958-738559067.png)

区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点：

1. n>0 时，根节点是唯一的，不可能存在多个根节点。
2. 每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。

### 1.2 树的相关概念

树有许多相关的术语与概念，在学习树的结构之前，我们要熟悉这些概念。

1. **子树**：除了根节点外，每个子节点都可以分为多个不相交的子树。（图二）
2. **孩子与双亲**：若一个结点有子树，那么该结点称为子树根的 "双亲"，子树的根是该结点的 "孩子"。在图一中，B、H 是 A 的孩子，A 是 B、H 的双亲。
3. **兄弟**：具有相同双亲的节点互为兄弟，例如 B 与 H 互为兄弟。
4. **节点的度**：一个节点拥有子树的数目。例如 A 的度为 2，B 的度为 1，C 的度为 3.
5. **叶子**：没有子树，也即是度为 0 的节点。
6. **分支节点**：除了叶子节点之外的节点，也即是度不为 0 的节点。
7. **内部节点**：除了根节点之外的分支节点。
8. **层次**：根节点为第一层，其余节点的层次等于其双亲节点的层次加 1.
9. **树的高度**：也称为树的深度，树中节点的最大层次。
10. **有序树**：树中节点各子树之间的次序是重要的，不可以随意交换位置。
11. **无序树**：树种节点各子树之间的次序是不重要的。可以随意交换位置。
12. **森林**：0 或多棵互不相交的树的集合。例如图二中的两棵树为森林。

![https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123013193-1365421796.png](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123013193-1365421796.png)

## 2. 二叉树

### 2.1 二叉树的定义

二叉树或者为空集，或者由一个根节点和两棵互不相交的、分别称为左子树和右子树的二叉树组成。从定义可以看出一棵二叉树：

1. 二叉树是有序树，区分左子树与右子树，不可以随意交换子树位置。
2. 一个节点的子树数量取值范围为 0，1，2。0 代表该节点是叶子节点，1 代表该节点只有左子树或只有右子树，2 代表该节点有左右子树。

### 2.2 二叉树的性质

#### 性质一：在二叉树的第 i 层上至多有 2^(i-1) 个节点 (i>=1)

证明：利用数学归纳法进行证明

1. 当 i==1 时，第 1 层节点数目为 2^(i-1) = 2^(1-1) = 2^0 = 1。显然成立，此时二叉树只有根节点。
2. 假设 i>1 时，第 i 层的节点数目为 2^(i-1)。  
根据假设，只需证明第 i+1 层节点数为 2^i 即可。  
由于二叉树每个节点最多有两个孩子，故第 (i+1) 层上的节点数最多是第 i 层的两倍。  
即：第 i+1 层上节点数最多为: 2* 2^(i-1) = 2 ^ i  
故假设成立，命题得证。

#### 性质二：深度为 k 的二叉树至多有 2^k-1 个节点

证明：二叉树节点数最多时，每层的节点树都必须最多。  
根据性质一，深度为 k 的二叉树的节点数最多为: 2^0 + 2^1 +....+2^(k-1) = 2 ^ k -1

#### 性质三：对任何一棵二叉树 T，如果终端节点数为 n0，度为 2 的节点数为 n2 ，那么 n0 = n2 +1

证明：二叉树节点度数最大为 2，则 ： n = n0 + n1 + n2 (等式一)  
从孩子个数角度出发： 度为 0 的节点没有孩子， 度为 1 的节点没有 1 个孩子，度为 2 的节点有 2 个孩子，孩子总数为 n0_0 + n1_1 +n2 _2 = n1+2_n2；树的所有节点中，只有根不是任何节点的孩 子，因此有 n -1 = n1 + 2* n2 , 即 n = n1 + 2* n2 + 1. （等式二）  
由等式一等式而可以推出 n0 = n2 +1

#### 性质四： 具有 n 个节点的完全二叉树的高度为至少为 log2(n+1)

证明：高度为 h 的二叉树最多有 2{h}–1 个结点。反之，对于包含 n 个节点的二叉树的高度至少为 log2(n+1)。

#### 性质五：如果对一棵有 n 个节点的完全二叉树的节点按层序编号（从第一层开始到最下一层，每一层从左到右编号），对任一节点 i 有如下特征

1. 如果 $i=1$，则节点为根节点，没有双亲。
2. 如果 $2 * i > n$，则节点 i 没有左孩子；否则其左孩子节点为 $2 * i$。（n 为节点总数）
3. 如果 $2 * i + 1 > n$ ，则节点 i 没有右孩子；否则其右孩子节点为 $2 * 1+1$

### 2.3 遍历二叉树

遍历平衡二叉树，就是以某种方式逐个 “访问” 二叉树的每一个节点。“访问”是指对节点的进行某种操作，例如输出节点的值。  
平衡二叉树是有序树，严格区分左子树与右子树，如果规定左子树先于右子树的次序，我们有四种方式遍历二叉树：

1. 前序遍历：根左右
2. 中序遍历：左根右
3. 后序遍历：左右根
4. 层序遍历

我们以如图的两棵二叉排序树进行遍历的算法演示。  
![遍历](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123158724-124348466.png)

#### 前序遍历

若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。（简记为：VLR）

前序遍历树 a：10 5 4 3 6 15 16  
前序遍历树 b：5 3 2 4 8 7 9

#### 中序遍历

若二叉树为空，则空操作返回，否则从根节点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。（简记为：LVR）

前序遍历树 a：3 4 5 6 10 15 16  
前序遍历树 b：2 3 4 5 7 8 9

二叉排序树的中序遍历刚好输出一个非递减的有序序列。

#### 后序遍历

若二叉树为空，则返回空操作，否则从左到右先叶子后节点的方式遍历访问左右子树，左右子树都访问结束，才访问根节点。（简称 LRV）

后序遍历树 a：3 4 6 5 16 15 10  
后序遍历树 b：2 4 3 7 9 8 5

#### 层序遍历

若二叉树为空，则返回空操作，否则从根节点开始向叶子节点遍历

层序遍历树 a: 10 5 15 4 6 16 3
层序遍历树 b: 5 3 8 2 4 7 9

#### 前驱与后继

对于一棵二叉排序树，中序遍历时刚好可以输出一个非递减的序列。例如前序遍历图九树 a：3 4 5 6 10 15 16，则可称

- 4 是 5 前驱节点，6 是 5 的后继节点
- 6 是 10 的前驱节点，15 是 10 的后继节点

一个节点的前驱节点有 3 种情况：

- 它有左子树，则左子树根节点为其前驱节点
- 它没有左子树，且它本身为右子树，则其父节点为其前驱节点
- 它没有左子树，且它本身为左子树，则它的前驱节点为 “第一个拥有右子树的父节点”

同样的，一个节点的后继节点也有三种情况：

- 它有右子树；则其后继节点为其右子树的最左节点
- 它没有右子树，但它本身是一个左孩子，则后继节点为它的双亲
- 它没有右子树，但它本身是一个右孩子，则其后继节点为 “具有左孩子的最近父节点”

### 2.4 删除节点

删除二叉排序树的某个节点有三种情况：

- 被删除节点同时有左子树与右子树。
- 被删除节点只有左子树或只有右子树。
- 被删除节点没有子树。

对于第一种情况，我们的处理方式是将前驱节点的值保存在当前结点，继而删除前驱节点。  
对于第二种情况，我们直接用子树替换被删节点。  
对于第三种情况，我们可以直接删除节点。  
![删除节点](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123404380-20125144.png)

### 2.5 查找元素

我们可以递归或非递归地进行元素的查找。元素的查找过程与元素的插入过程一致，也是在不断地与当前结点进行比较，若值比当前节点的值大，则在右子树进行查找，若值比当前节点的值小，则在左子树进行查找，可以看到这是一个很适合递归操作的过程。而由于二叉排序树这种左小右大的节点特征，也很容易进行非递归查找。

- 查找最值元素

二叉查找树的最小值位于其最左节点上；最大值位于其最右节点上：  
![查找](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123419474-1672539695.png)

### 2.6 销毁二叉树

使用后序遍历递归销毁二叉树

### 2.8 二叉树的分类

根据定义，一棵二叉树有 5 中基本形态：斜树、满二叉树、完全二叉树、二叉查找树

![二叉树的分类](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123032474-2120163975.png)

#### 斜树

所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树。左斜树和右子树统称为斜树。  
斜树已经退化成线性结构，二叉树在查找上表现出来优异性能在斜树得不到体现。  
![https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123049943-94459443.png](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123049943-94459443.png)
*注意：为了只关注重点，我们所有的节点都采用统一浅绿色着色，若有特殊节点将在图中备注*

#### 满二叉树

满二叉树要满足两个条件：

1. 所有的节点都同时具有左子树和右子树。
2. 所有的叶子节点都在同一层上。

在同样深度的二叉树中，满二叉树的节点数目是最多的，叶子数也是最多的。  
![满二叉树](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123057833-481620316.png "满二叉树")

#### 完全二叉树

在一棵二叉树中，只有最下两层的度可以小于 2，并且最下一层的叶子节点集中出现在靠左的若干位置上。  
或者这样定义：对一棵具有 n 个节点的二叉树按层序从左到右编序，二叉树树某个节点的编序与同样位置的满二叉树节点的编序相同如果所有节点都满足这个条件，则二叉树为完全二叉树。  
从定义可以看出： 满二叉树一定是完全二叉树；完全二叉树不一定是满二叉树。

![完全二叉树](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123116411-655334813.png "完全二叉树")

#### 二叉查找树

二叉排序树也称为二叉搜索树或二叉排序树。二叉排序树的节点包含键值 key。二叉排序树或者是一棵空树，否则要求：

1. 若它的左子树不为空，那么左子树上所有节点的 key 都小于根节点的 key
2. 若它的右子树不为空，那么右子树上所有节点的 key 都大于根节点的 key
3. 它的左右子树也分别为二叉排序树

根据定义，二叉查找树中没有重复 key 的节点。

![二叉查找树](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123125833-1672680802.png "二叉查找树")

在实际的应用中，二叉排序树的应用比较多，我们后面要讲的 AVL 树本身也是一种二叉排序树。

- 插入新节点

假设我们要为数组 a[] = {10 ， 5 ， 15 ， 6 ， 4 ， 16} 构建一个二叉排序树，我们按顺序逐个插入元素。

![插入](https://images2015.cnblogs.com/blog/610439/201601/610439-20160129123148364-664832426.png)

插入过程是这样的：

1. 如果是空树，则创建一个新节点，新节点作为根，因此以元素 10 构建的节点为该二叉查找树的根。
2. 插入 5，5 比 10 小，与 10 的左孩子节点进行比较，10 的左孩子节点为空，进行插入。
3. 插入 15，15 比 10 大，与 10 的右孩子节点进行比较，10 的右孩子节点为空，进行插入。
4. 插入 6，6 比 10 小，与 10 的左孩子节点 5 比较；6 比 5 大，与 5 的右孩子节点进行比较，5 的右孩子为空，进行插入。
5. 插入 4，4 比 10 小，与 10 的左孩子节点 5 比较；4 比 5 小，与 5 的左孩子节点进行比较，5 的左孩子为空，进行插入。
6. 插入 16，16 比 10 大，与 10 的右孩子节点 15 比较；16 比 15 大，与 15 的右孩子节点进行比较，15 的右孩子为空，进行插入。

从这个过程我们可以总结出插入新元素的步骤：

1. 寻找元素合适的插入位置：**新元素与当前结点进行比较，若值大于当前结点，则从右子树进行寻找；否则从左子树进行寻找**.
2. 找到插入位置之后，以元素的值构建新节点，插入二叉排序树中

#### 平衡二叉树 or AVL树

平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
![AVL](http://ww1.sinaimg.cn/large/bb854e66ly1g68nu7h13rj20bz073glo.jpg)
平衡二叉树实现的大部分过程和二叉查找树是一样的（学平衡二叉树之前一定要会二叉查找树），区别就在于插入和删除之后要写一个旋转算法去维持平衡，维持平衡需要借助一个节点高度的属性。

##### 基本概念

现在又 a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8} 需要构建二叉排序树。在没有学习平衡二叉树之前，根据二叉排序树的特性，通常会将它构建成如下左图。虽然完全符合二叉排序树的定义，但是对这样高度达到 8 的二叉树来说，查找是非常不利的。因此，更加期望构建出如下右图的样子，高度为 4 的二叉排序树，这样才可以提供高效的查找效率。
![AVL](http://ww1.sinaimg.cn/large/bb854e66ly1g68nxmooxmj20dh04tq3h.jpg)

平衡二叉树是一种二叉排序树，是一种高度平衡的二叉树，其中每个结点的左子树和右子树的高度至多等于 1。

1. 要么是一棵空树，要么左右都是平衡二叉树，且左子树和右子树深度之绝对值不超过
1. 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF，那么平衡二叉树上的所有结点的平衡因子只可能是 - 1、0 和 1。
1. 只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。

平衡二叉树的前提是它是一棵二叉排序树。距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为最小不平衡子树。如下图所示，当插入结点 37 时，距离它最近的平衡因子的绝对值超过 1 的结点是 58。
![插入](http://ww1.sinaimg.cn/large/bb854e66ly1g68nyvnb6aj20d704l0t4.jpg)

##### 插入原理

根据二叉平衡树的定义，一定保持左右子树深度绝对值小于 1. 在平衡二叉树插入工作一定考虑深度差，在 AVL 树进行插入工作时候，困难在于可能破坏 AVL 树的平衡属性。例如在下图
![插入](http://ww1.sinaimg.cn/large/bb854e66ly1g68o1dep7gj20ec05wwex.jpg)
上图中插入一个节点 6，那么如果不进行后续处理就会破坏树的平衡性。因为 8 的左子树深度为 1，而右子树深度为 - 1.

针对此类问题，需要根据树的实际结构进行几种简单的旋转（rotation）操作就可以让树恢复 AVL 树的平衡性质

##### 旋转问题

对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差 2。容易看出，这种不平衡出现在下面四种情况：
![旋转](http://ww1.sinaimg.cn/large/bb854e66ly1g68o4pvy2fj20lt08iweu.jpg)

1. 6 节点的左子树 3 节点高度比右子树 7 节点大 2，左子树 3 节点的左子树 1 节点高度大于右子树 4 节点，这种情况成为左左。

2. 6 节点的左子树 2 节点高度比右子树 7 节点大 2，左子树 2 节点的左子树 1 节点高度小于右子树 4 节点，这种情况成为左右。

3. 2 节点的左子树 1 节点高度比右子树 5 节点小 2，右子树 5 节点的左子树 3 节点高度大于右子树 6 节点，这种情况成为右左。

4. 2 节点的左子树 1 节点高度比右子树 4 节点小 2，右子树 4 节点的左子树 3 节点高度小于右子树 6 节点，这种情况成为右右。

从图 2 中可以可以看出，1 和 4 两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2 和 3 两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。

##### 旋转操作

![AVL树的旋转](http://ww1.sinaimg.cn/large/bb854e66ly1g68qe22nr3j20m80fqtaf.jpg)

- 单旋转
单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图 3 是左左情况的解决方案，节点 k2 不满足平衡特性，因为它的左子树 k1 比右子树 Z 深 2 层，而且 k1 子树中，更深的一层的是 k1 的左子树 X 子树，所以属于左左情况。
![左左旋转](http://ww1.sinaimg.cn/large/bb854e66ly1g68o6qx9a1j20eq06dt8v.jpg)
为使树恢复平衡，我们把 k2 变成这棵树的根节点，因为 k2 大于 k1，把 k2 置于 k1 的右子树上，而原本在 k1 右子树的 Y 大于 k1，小于 k2，就把 Y 置于 k2 的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。
这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵 AVL 树，因为 X 向上一移动了一层，Y 还停留在原来的层面上，Z 向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得 X 高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。
右旋转原理：**获取失去平衡结点以及左结点，为了让 lchild 作为根节点，将 lchild 的 rchild 挂接到之前左结点上，然后在挂接到 s->rchild。**
左旋转原理正好相反，**让其右结点作为根节点**

- 双旋转
对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图 4 是左右情况的解决方案，节点 k3 不满足平衡特性，因为它的左子树 k1 比右子树 Z 深 2 层，而且 k1 子树中，更深的一层的是 k1 的右子树 k2 子树，所以属于左右情况。
![左右旋转](http://ww1.sinaimg.cn/large/bb854e66ly1g68o9rv9g7j20lt06vjrv.jpg)
为使树恢复平衡，我们需要进行两步，第一步，把 k1 作为根，进行一次 z 左旋转，旋转之后就变成了左左情况，所以第二步再进行一次右旋转，最后得到了一棵以 k2 为根的平衡二叉树树。

#### 红黑树

红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

但它是如何保证一棵n个结点的红黑树的高度始终保持在logn的呢？这就引出了红黑树的5个性质：

- 每个结点要么是红的要么是黑的。  
- 根结点是黑的。  
- 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
- 如果一个结点是红的，那么它的两个儿子都是黑的。  
- 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
![红黑树](http://ww1.sinaimg.cn/large/bb854e66ly1g68pas1zusj20m80apdgb.jpg)
此图忽略了叶子和根部的父结点。同时，上文中我们所说的 "叶结点" 或"NULL结点"，如上图所示，它不包含数据而只充当树在此结束的指示

## 3. B树 B+树 B*树

B 树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树。许多数据库系统都一般使用 B 树或者 B 树的各种变形结构，如下文即将要介绍的 B + 树，B * 树来存储信息。

B 树与红黑树最大的不同在于，B 树的结点可以有许多子女，从几个到几千个。与红黑树的相同之处在于，一棵含 n 个结点的 B 树的高度也为 O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B 树可以在 O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

如下图所示，即是一棵 B 树，一棵关键字为英语中辅音字母的 B 树，现在要从树种查找字母 R（包含 n[x] 个关键字的内结点 x，x 有 n[x]+1 个子女（也就是说，一个内结点 x 若含有 n[x] 个关键字，那么 x 将含有 n[x]+1 个子女）。所有的叶结点都处于相同的深度，带阴影的结点为查找字母 R 时要检查的结点）：

![B树](https://img-blog.csdn.net/20160817204439639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

  B 树又叫平衡多路查找树。**一棵 m 阶的 B 树的特性如下**：

- 树中每个结点最多含有 m 个孩子（m>=2）；

- 除根结点和叶子结点外，其它每个结点至少有 [ceil(m / 2)] 个孩子（其中 ceil(x)是一个取上限的函数）；

- 若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

- 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息 (可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为 null)；

- 每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：  
  a)   Ki (i=1...n) 为关键字，且关键字按顺序升序排序 K(i-1)< Ki。  
  b)   Pi 为指向子树根的接点，且指针 P(i-1) 指向子树中所有结点的关键字均小于 Ki，但都大于 K(i-1)。
  c)   关键字的个数 n 必须满足： **[ceil(m / 2)-1]<= n <= m-1。**

### B-Tree 数据结构

#### B-Tree 的度

![B-Tree 的度](http://hi.csdn.net/attachment/201106/7/8394323_13074405906V6Q.jpg)
B-Tree 中每个节点能包含的关键字的数量有一个上界和下界。下界称为 B-Tree 的最小度数。

#### B-Tree 的高度

- a) 从 B-Tree 的最小度来计算

B 树上大部分操作所需的磁盘存取次数与 B 树的高度成正比。下面分析 B 树的最坏高度情况。如果 n>=1, 则对任意一棵包含 n 个关键字、高度为 h（从 0 开始）、最小度数 t>=2 的 B 树有： h = logt((n+1)/2);

证明：

         如果一棵 B-Tree 的高度为 h，其根节点至少包括一个关键字，而其他节点至少 t-1 个关键字。深度为 1 的节点至少有两个，深度为 2 的节点至少有 2t 个，深度为 3 的节点至少为 2t2，…..，深度为 h 的节点至少为 2th-1，因此，

         所以：h = logt((n+1)/2);

- b) 从 B-Tree 的阶数计算

若 B 树某一非叶子节点包含 N 个关键字，则此非叶子节点含有 N+1 个孩子结点，而所有的叶子结点都在第 I 层，我们可以得出：

- 因为根至少有两个孩子，因此第 2 层至少有两个结点。
- 除根和叶子外，其它结点至少有┌m/2┐个孩子，
- 因此在第 3 层至少有 2*┌m/2┐个结点，
- 第 4 层至少有 2*(┌m/2┐^2) 个结点，
- 在第 I 层至少有 2*(┌m/2┐^(l-2) ) 个结点，于是有： N+1 ≥ 2*┌m/2┐I-2；
- 考虑第 L 层的结点个数为 N+1，那么 2*(┌m/2┐^(l-2)）≤N+1，也就是 L 层的最少结点数刚好达到 N+1 个，即： I≤ log┌m/2┐((N+1)/2 )+2；

　所以

- 当 B 树包含 N 个关键字时，B 树的最大高度为 l-1（因为计算 B 树高度时，叶结点所在层不计算在内），即：l - 1 = **log┌m/2┐((N+1)/2 )+1**。

### B+ 树

B+ 树是 B- 树的变体，也是一种多路搜索树：

其定义基本与 B- 树同，除了：

1. 非叶子结点的子树指针与关键字个数相同；

2. 非叶子结点的子树指针 P[i]，指向关键字值属于 [K[i],K[i+1]) 的子树（B- 树是开区间）；

3. 为所有叶子结点增加一个链指针；

4. 所有关键字都在叶子结点出现

B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（B- 树可以在

非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

#### B+ 的特性

1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好
是有序的；

2. 不可能在非叶子结点命中；

3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储
（关键字）数据的数据层；

4. 更适合文件索引系统；

![B + 树](https://p-blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG)  

### B*树

B* 树是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针；B* 树定义了非叶子结点关键字个数至少为 (2/3)*M，即块的最低使用率为 2/3（代替 B+ 树的 1/2）；

B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中 1/2 的数据复制到新结点，最后在父结点中增加新结点的指针；B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制 1/3 的数据到新结点，最后在父结点增加新结点的指针；

所以，B* 树分配新结点的概率比 B+ 树要低，空间使用率更高；

![B*树](https://p-blog.csdn.net/images/p_blog_csdn_net/manesking/6.JPG)  

## 4. LSM树

存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。

### 原理

把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。

### 读写性能

LSM树与B树相比，牺牲了部分的读性能，大幅提高写性能。
LSM Tree，对于最简单的二层LSM Tree而言，内存中的数据和磁盘你中的数据merge操作，如下图：
![读写](http://ww1.sinaimg.cn/large/bb854e66ly1g68pyzd203j20ce09udfv.jpg)

### hbase与LSM树

数据会先写到内存中，为了防止内存数据丢失，写内存的同时需要持久化到磁盘，对应了HBase的MemStore和HLog；
MemStore中的数据达到一定的阈值之后，需要将数据刷写到磁盘，即生成HFile（也是一颗小的B+树）文件；
hbase中的minor（少量HFile小文件合并）major（一个region的所有HFile文件合并）执行compact操作，同时删除无效数据（过期及删除的数据），多棵小树在这个时机合并成大树，来增强读性能。

针对LSM树读性能hbase的优化

Bloom-filter:就是个带随机概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定数据的。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。
compact:小树合并为大树:因为小树性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N/m)*log2n的查询了。
![Hbase架构图](http://ww1.sinaimg.cn/large/bb854e66ly1g68q0vadttj20l40azt9r.jpg)

## 参考

1. [数据结构图文解析之：树的简介及二叉排序树C++模板实现](http://www.cnblogs.com/QG-whz/p/5168620.html#_label0)

2. [教你初步了解红黑树](https://blog.csdn.net/v_JULY_v/article/details/6105630)

3. [红黑树论文](http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf)

4. [平衡二叉树、B树、B+树，B*树的区别](https://mp.weixin.qq.com/s?src=11&timestamp=1566476831&ver=1806&signature=-5Kd-h2gU0HXQ2ONAvA9afXdnv52byM7BcP995f1lg0*EfZbqmw6dCJqW*EI8NaWiStTdKYRfLa8CfAQI-fzPc4mI2HoMDhjvsNP4ZeaZIFRzTveTgcqevhGhbKE9RJT&new=1)
