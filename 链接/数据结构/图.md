# 图

图通常用来表示和存储具有“多对多”关系的数据，是数据结构中非常重要的一种结构。

## 图的定义

定义：图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。
![图](http://ww1.sinaimg.cn/large/bb854e66ly1g69q5p1fx3j20ma0blaaa.jpg)
在上图中，共有 V0，V1，V2，V3 这 4 个顶点，4 个顶点之间共有 5 条边。

注

- 当线性表没有数据节点时，线性表为空表。
- 树中没有节点时，树为空树。
- 但是，在图中不允许没有顶点，但是可以没有边。

## 图的分类

- 图是由顶点和边组成的：(可以无边，但至少包含一个顶点)
  - 一组顶点：通常用 V(vertex) 表示顶点集合
  - 一组边：通常用 E(edge) 表示边的集合

### 有向图和无向图

- 无向图：若图中任意两个顶点之间的边均是无向边，则称该图为无向图。
  - 无向边：若顶点 V0 和 V1 之间的边没有方向，则称该边为无向边(V0,V1)，(V0,V1) 与 (V1,V0) 意义相同，表示 V0 和 V1 之间有连接。因此，(Vi，Vj)和(Vj，Vi)表示的是同一条边。注意，无向图是用小括号，而下面介绍的有向图是用尖括号。下面所示图中的边均为无向边。
![无向边](http://ww1.sinaimg.cn/large/bb854e66ly1g69q5p1fx3j20ma0blaaa.jpg)
- 有向图：若图中任意两个顶点之间的边均是有向边，则称该图为有向图。
  - 有向边：若顶点 V0 和 V1 之间的边有方向，则称该边为有向边，与表示的意义是不同的，表示从 V0 连接到 V1 ，V0 称为尾，V1 称为头。表示从 V1 连接到 V0 ，V1 称为尾， V0 称为头。因此，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。注意，有向边又称为弧。下面所示图中的边为有向边。
![有向边](http://ww1.sinaimg.cn/large/bb854e66gy1g6bqq08k5cj20nd0b9wes.jpg)

- 无向完全图和有向完全图
我们将具有n(n-1)/2条边的无向图称为无向完全图。同理，将具有n(n-1)条边的有向图称为有向完全图。

### 有权图和无权图

- 有权图：每条边具有一定的权重 (weight)，通常是一个数字
- 无权图：每条边均没有权重，也可以理解为权为 1

### 连通图和非连通图

- 连通图：所有的点都有路径相连
  - 强连通图（有向图）：强连通图是对于有向图而言的，与无向图的连通图类似。
- 非连通图：存在某两个点没有路径相连

### 网

  带”权值”的连通图称为网。

### 图中的顶点有度的概念

- 度 (Degree)：
  - 对于无向图，顶点的度表示以该顶点作为一个端点的边的数目。
  - 对于有向图，顶点的度分为入度和出度。
- 入度表示以该顶点为终点的入边数目。
- 出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。

记住，不管是无向图还是有向图，顶点数n，边数e和顶点的度数有如下关系：

$$e=\frac{1}{2}\sum_{i=1}^{n}D(V_i)$$

### 路径、路径长度和回路

- 路径，比如在无向图G中，存在一个顶点序列Vp,Vi1,Vi2,Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…,(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。即依次遍历顶点序列之间的边所形成的轨迹。
  一系列顶点构成路径，路径中所有顶点都由边连接。
- 路径长度，是指一条路径上经过的边的数量。
- 回路，指一条路径的起点和终点为同一个顶点。

## 图的创建与遍历

### 图的两种存储结构

#### 邻接矩阵

图的数组存储方式也称为邻接矩阵存储。图中的数据信息包括：顶点信息和描述顶点之间关系的边的信息，将这两种信息存储在数组中即为图的数组存储。
首先，创建顶点数组，顶点数组中存储的是图的顶点信息，采用一维数组的方式即可存储所有的顶点信息。存储图中边的信息时，由于边是描述顶点与顶点之间关系的信息，因此需要采用二维数组进行存储。

  定义：设图 G 有 n 个顶点，则邻接矩阵是一个n X n的方阵A，定义为：
![邻接矩阵](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs16g7eqj20m803jq2u.jpg)
其中，或者(Vi , Vj,)表示顶点 Vi 与顶点 Vj 邻接。wi,j表示边的权重值。

例如：下图所示的无向图，采用数组存储形式如下。
![无向图](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs1zp71pj20u00bx3zs.jpg)
注：图中的数组存储方式简化了边的权值为 1 。

无向图的数组存储主要有以下特性：

（1）顶点数组长度为图的顶点数目n。边数组为n X n的二维数组。
（2）边数组中，A[i][j] =1代表顶点i与顶点j邻接，A[i][j] = 0代表顶点i与顶点j不邻接。
（3）在无向图中。由于边是无向边，因此顶点的邻接关系是对称的，边数组为对称二维数组。
（4）顶点与自身之间并未邻接关系，因此边数组的对角线上的元素均为0。
（5）顶点的度即为顶点所在的行或者列1的数目。例如：顶点V2的度为3，则V2所在行和列中的1的数目为3。
当图为有向图时，图的数组存储方式要发生变化。
例如：下面所示的有向图，采用数组存储形式如下。
![有向图](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs31m2zgj20u00c2jrx.jpg)
有向图的数组存储主要有以下特性：

（1）顶点数组长度为图的顶点数目n。边数组为n X n的二维数组。
（2）边数组中，数组元素为1，即A[i][j] = 1,代表第i个顶点与第j个顶点邻接，且i为尾，j为头。 A[i][j] = 0代表顶点与顶点不邻接。
（3）在有向图中，由于边存在方向性，因此数组不一定为对称数组。
（4）对角线上元素为0。
（5）第i行中，1的数目代表第i个顶点的出度。例如：顶点V1的出度为2，则顶点V1所在行的1的数目为2。
（6）第j列中，1的数目代表第j个顶点的入度。例如：V3的入度为1，则V3所在列中1的数目为1。

数组存储方式优点：
  数组存储方式容易实现图的操作。例如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。
数组存储方式缺点：
  采用数组存储方式，图若有n个顶点则需要n2个单元存储边(弧)，空间存储效率为O(n2)。 当顶点数目较多，边数目较少时，此时图为稀疏图，这时尤其浪费空间。
  例如：下面所示的图，图中有 9 个顶点，边数为10，需要 9X9 的二维数组，而实际存储边信息空间只有10，造成空间浪费。
![无向图](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs43dg1xj20u00bd3zk.jpg)
![无向图的存储数组](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs4poukxj20u00gata7.jpg)

#### 邻接表

当使用数组存储时，主要有以下三个问题：

- 对于一个图，若图中的顶点数目过大，则无法使用邻接矩阵进行存储。因为在分配数组内存时可能会导致内存分配失败。
- 对于某些稀疏图（即顶点数目多，边数目少），创建的数组大小很大，而真正存储的有用信息又很少，这就造成了空间上的浪费。
- 有时两个点之间不止存在有一条边，这是用邻接矩阵就无法同时表示两条以上的边。

针对以上情况，提出了一种特殊的图存储方式，让每个节点拥有的数组大小刚好就等于它所连接的边数，由此建立一种邻接表的存储方式。

邻接表存储方法是一种数组存储和链式存储相结合的存储方法。在邻接表中，对图中的每个顶点建立一个单链表，第 i 个单链表中的结点依附于顶点 Vi 的边（对有向图是以顶点Vi为尾的弧）。链表中的节点称为表节点，共有 3个域，具体结构见下图：
![表节点](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs5nkd63j20se07w0ss.jpg)
表结点由三个域组成，adjvex存储与Vi邻接的点在图中的位置，nextarc存储下一条边或弧的结点，data存储与边或弧相关的信息如权值。

除表节点外，需要在数组中存储头节点，头结点由两个域组成，分别指向链表中第一个顶点和存储Vi的名或其他信息。具体结构如下图：
![头节点](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs6fimhdj20qa06yq2w.jpg)
其中，data域中存储顶点相关信息，firstarc指向链表的第一个节点。
无向图采用邻接表方式存储
例如：下面所示的无向图采用邻接表存储。
![无向图](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs78yt6pj20rv0bjgm0.jpg)
采用邻接表方式存储图 6.1 中的无向图，绘图过程中忽略边节点的info信息，头结点中的 data 域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，则可以创建3个表节点，表节点中adjvex分别存储V2、V3、V4的索引1、2、3，按照此方式，得到的邻接表为：
![邻接表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs7k11a5j20u00bdgmc.jpg)
无向图的邻接表存储特性：

（1）数组中头节点的数目为图的顶点数目。
（2）链表的长度即为顶点的度。例如：V1顶点的度为3，则以V1为头节点的链表中表节点的数目为3。

有向图采用邻接表方式存储
例如：下图所示的有向图采用邻接表存储。
![邻接表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs94cmdyj20u00ddmy7.jpg)
采用邻接表方式存储图6.3中的有向图，绘图过程中忽略边节点的info信息，头结点中的data域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，但是以V1顶点为尾的边只有两条，即和因此，创建2个表节点。表节点中adjvex分别存储V3、V4的索引2、3，按照此方式，得到的邻接表为：
![邻接表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bs9jik3mj20u00cgmxn.jpg)
有向图的邻接表存储特性：

（1）数组中表节点的数目为图的顶点数目。
（2）链表的长度即为顶点的出度。例如V1的出度为2，V1为头节点的链表中，表节点的数目为2。
（3）顶点Vi的入度为邻接表中所有adjvex值域为i的表结点数目。例如：顶点V3的入度为4，则链表中所有adjvex值域为2的表结点数目为4。

注：图采用邻接表的方式表示时，其表示方式是不唯一的。这是因为在每个顶点对应的单链表中，各边节点的链接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。

#### 逆邻接表

在邻接表中，可以轻易的得出顶点的出度，但是想要得到顶点的入度，则需要遍历整个链表。为了便于确定顶点的入度，可以建立有向图的逆邻接表。逆邻接表的建立与邻接表相反。
  采用逆邻接表的方式存储图3.2所示的无向图。以V3顶点为例，V3顶点的邻接顶点为V1、V2、V4、V5，以V3顶点为头的边有4条，即、、、因此，创建4个表节点。表节点中adjvex分别存储V0、V1、V3、V4的索引0、1、3、4，按照此方式，得到的逆邻接表为：
![逆邻接表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsamb9muj20u00blaah.jpg)

#### 十字链表

对于有向图而言，邻接链表的缺陷是要查询某个顶点的入度时需要遍历整个链表，而逆邻接链表在查询某个顶点的出度时要遍历整个链表。为了解决这些问题，十字链表将邻接链表和逆邻接链表综合了起来，而得到的一种十字链表。在十字链表中，每一条边对应一种边节点，每一个顶点对应为顶点节点。

顶点节点
顶点节点即为头节点，由3个域构成，具体形式如下
![十字链表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsbsvniej20t7067t8k.jpg)
其中，data域存储与顶点相关的信息，firstin和firstout分别指向以此顶点为头或尾的第一个边节点。
边节点
在边节点为链表节点，共有 5 个域，具体形式如下：
![十字链表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsc794eij20u004ot8t.jpg)
其中，尾域tailvex和头域headvex分别指向尾和头的顶点在图中的位置。链域hlink指向头相同的下一条边，链域tlink指向尾相同的下一条边。info 存储此条边的相关信息。
例如：图8.1所示的有向图，采用十字链表存储图方式。
![十字链表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bscl31a9j20u00bbmxr.jpg)

采用十字链表的方式存储图8.1中的有向图，绘图过程忽略边节点中的info信息，表头节点中的data域存储顶点名称。以V1顶点为例，顶点节点的data域存储V1顶点名，firstin存储以V1顶点为头第一个边节点，以V1顶点为头边为，firstout存储以以V1顶点为尾第一个边节点，对应边为。按照此规则，得到的十字链表存储为：
![十字链表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsd814dfj20u0092dgf.jpg)
注：采用十字链表存储时，表头节点仍然使用数组存储，采用下标索引方式获取。

#### 邻接多重表

对于无向图而言，其每条边在邻接链表中都需要两个结点来表示，而邻接多重表正是对其进行优化，让同一条边只用一个结点表示即可。邻接多重表仿照了十字链表的思想，对邻接链表的边表结点进行了改进。
重新定义的边结点结构如下图：
![邻接多重表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsebfxjnj20u004ta9v.jpg)
其中，ivex和jvex是指某条边依附的两个顶点在顶点表中的下标。 ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。info存储边的相关信息。
  重新定义的顶点结构如下图：
![邻接多重表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bseo594lj20mx04tt8i.jpg)
其中，data存储顶点的相关信息，firstedge指向第一条依附于该顶点的边。
例如：图9.1所示的无向图，采用邻接多重表存储图。
![邻接多重表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsez4j6ij20pr0ba74e.jpg)
图 9.1 所示的无向图，采用邻接多重表存储，以 V0 为例，顶点节点的data域存储V0名称，firstedge 指向(V0 , V1)边，边节点中的ilink指向依附V0顶点的下一条边(V0 , V3)，jlink指向依附V1顶点的下一条边(V1 , V2)，按照此方式建立邻接多重表：
![邻接多重表](http://ww1.sinaimg.cn/large/bb854e66gy1g6bsfby72zj20u00d6q3f.jpg)

## 图的两种遍历方法

确定从一个指定的顶点可以到达其他哪些顶点。这是经常对图执行的操作。我们可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。

而图上这些操作是用算法执行的。在图上可以执行以下两种遍历算法用于搜索：

### 深度优先搜索遍历

![深度优先遍历](http://ww1.sinaimg.cn/large/bb854e66gy1g6byp00b18j20go082gls.jpg)

深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是：
a) 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。

b)然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。

c) 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。

简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止

这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。

图示如下：
![深度优先搜索遍历](http://ww1.sinaimg.cn/large/bb854e66gy1g6byptl07hj208o07naa8.jpg)
注：红色数字代表遍历的先后顺序，所以图(e)无向图的深度优先遍历的顶点访问序列为：V0，V1，V2，V5，V4，V6，V3，V7，V8

如果采用邻接矩阵存储，则时间复杂度为O(n2)；当采用邻接表时时间复杂度为O(n+e)。

深度优先搜索的算法比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。
![深度优先搜索遍历](http://ww1.sinaimg.cn/large/bb854e66gy1g6bysk8p2pg20go0cihdt.gif)
> 注意 深度优先算法属于盲目搜索，无法保证搜索到的路径为最短路径。
> DFS 的实现近似于 BFS，但使用的是栈而不是队列。

### 广度优先搜索遍历

![广度优先搜索遍历](http://ww1.sinaimg.cn/large/bb854e66gy1g6byvm9eaoj20go084wep.jpg)

广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是：

a) 首先访问出发点Vi

b) 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。

c) 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。
图示如下：
![广度优先搜索遍历](http://ww1.sinaimg.cn/large/bb854e66gy1g6bywbtrjwj20cn09wwez.jpg)
因此，图(f)采用广义优先搜索遍历以V0为出发点的顶点序列为：V0，V1，V3，V4，V2，V6，V8，V5，V7

如果采用邻接矩阵存储，则时间复杂度为O(n2)，若采用邻接表，则时间复杂度为O(n+e)。

简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层

广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下：
查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中;
从图中取下一个顶点v，添加到已访问的顶点列表
将所有与v相邻的未访问顶点添加到队列。

### 最小生成树和最短路径

#### 最小生成树

什么是最小生成树呢？在弄清什么是最小生成树之前，我们需要弄清什么是生成树？

用一句语简单概括生成树就是：生成树是将图中所有顶点以最少的边连通的子图。

比如图(g)可以同时得到两个生成树图(h)和图(i)
![最小生成树](http://ww1.sinaimg.cn/large/bb854e66gy1g6c7sj0r8sj20h90eqt9f.jpg)
知道了什么是生成树之后，我们就很容易理解什么是最小生成树了。所谓最小生成树，用一句话总结就是：权值和最小的生成树就是最小生成树。

比如上图中的两个生成树，生成树1和生成树2，生成树1的权值和为：12，生成树2的权值为：14，我们可以证明图(h)生成树1就是图(g)的最小生成树。

那么如何构造最小生成树呢？可以使用普里姆算法。

#### 最短路径

求最短路径也就是求最短路径长度。下面是一个带权值的有向图，表格中分别列出了顶点V1其它各顶点的最短路径长度。
![最短路径](http://ww1.sinaimg.cn/large/bb854e66gy1g6c7tjf2qij206k07dq30.jpg)

| 源点 |       最短路径 | 终点  |       | 路径长度 |
| ---- | -------------: | :---: | :---: | :------: |
| V1   |     V1，V3，V2 |  V2   | 中转  |    5     |
| V1   |         V1，V3 |  V3   | 直达  |    3     |
| V1   | V1，V3，V2，V4 |  V4   | 中转  |    10    |
| V1   |     V1，V3，V5 |  V5   | 中转  |    18    |

> 表：顶点V1到其它各顶点的最短路径表

从图中可以看出，顶点V1到V4的路径有3条(V1，V2，V4)，(V1，V4)，(V1，V3，V2，V4)，其路径长度分别为15，20和10，因此，V1到V4的最短路径为(V1，V3，V2，V4)。

那么如何求带权有向图的最短路径长度呢？可以使用 **迪杰斯特拉(Dijkstra)算法** 。

## 图的时间与空间复杂度

我们接触了图的一些基础操作，如何添加和删除一个顶点或一条边，以下是前文涵盖内容的小结：

|                                  |           邻接表 | 邻接矩阵  |
| -------------------------------- | ---------------: | :-------: |
| 空间复杂度                       |  O(\|V\|+ \|E\|) | O(\|V\|²) |
| 添加顶点                         |             O(1) | O(\|V\|²) |
| 移除顶点                         | O(\|V\| + \|E\|) | O(\|V\|)² |
| 添加边                           |             O(1) |   O(1)    |
| 移除边 (基于 Array 实现)         |         O(\|E\|) |   O(1)    |
| 移除边 (基于 HashSet 实现)       |             O(1) |   O(1)    |
| 获取相邻的顶点                   |         O(\|E\|) | O(\|V\|)  |
| 判断是否相邻 (基于 Array 实现)   |         O(\|E\|) |   O(1)    |
| 判断是否相邻 (基于 HashSet 实现) |             O(1) |   O(1)    |

正如上表所示，邻接表中几乎所有的操作方法都是更快的。邻接矩阵比邻接表性能更高的方法只有一处：检查顶点是否与其他顶点相邻，然而使用 HashSet 而不是 Array 实现邻接表的话，也能在恒定时间内获取结果 :)

## 参考

1. [图](https://www.cnblogs.com/mcgrady/archive/2013/09/23/3335847.html)
2. [数据结构与算法：图和图算法(一)](https://segmentfault.com/a/1190000010794621#articleHeader13)
3. [数据结构与算法 - 图论](https://zhuanlan.zhihu.com/p/25498681)
4. [几道和「广度优先搜索」有关的算法面试题](https://www.itcodemonkey.com/article/13875.html)
5. [[译文] 初学者应该了解的数据结构： Graph
](https://juejin.im/post/5b5bb171f265da0f5d4cdf33?hmsr=joyk.com&utm_source=joyk.com&utm_medium=referral#heading-9)
6. [数据结构与算法——图论基础与图存储结构
](https://www.itcodemonkey.com/article/13876.html)
7. [从简单二叉树问题重新来看深度优先搜索
](https://www.itcodemonkey.com/article/15269.html)