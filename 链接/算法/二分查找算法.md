# 二分查找算法

二分查找又称折半查找，它是一种效率较高的查找方法。

折半查找的算法思想是将数列按有序化(递增或递减)排列，查找过程中采用跳跃式方式查找，即先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，将查找区间缩小一半。 折半查找是一种高效的查找方法。它可以明显减少比较次数，提高查找效率。但是，折半查找的先决条件是查找表中的数据元素必须有序。

折半查找法的优点是比较次数少，查找速度快，平均性能好;其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。

## 算法描述

- 首先确定整个查找区间的中间位置 mid = （ left + right ）/ 2

- 用待查关键字值与中间位置的关键字值进行比较；
  - 若相等，则查找成功
  - 若大于，则在后（右）半个区域继续进行折半查找
  - 若小于，则在前（左）半个区域继续进行折半查找

- 对确定的缩小区域再按折半公式，重复上述步骤。

最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存放。

## 代码实现

```JAVA
public class BinarySearch {
    /**
    * 二分查找算法
    *
    * @param srcArray 有序数组
    * @param key 查找元素
    * @return key的数组下标，没找到返回-1
    */
    public static void main(String[] args) {
        int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};
        System.out.println(binSearch(srcArray, 0, srcArray.length - 1, 222));
        System.out.println(binSearch(srcArray,81));
    }

  /**
     * 二分查找递归实现。
     * @param srcArray  有序数组
     * @param start 数组低地址下标
     * @param end   数组高地址下标
     * @param key  查找元素
     * @return 查找元素不存在返回-1
     */
    public static int binSearch(int srcArray[], int start, int end, int key) {
        int mid = (end - start) / 2 + start;
        if (srcArray[mid] == key) {
            return mid;
        }
        if (start >= end) {
            return -1;
        } else if (key > srcArray[mid]) {
            return binSearch(srcArray, mid + 1, end, key);
        } else if (key < srcArray[mid]) {
            return binSearch(srcArray, start, mid - 1, key);
        }
        return -1;
    }

/**
     * 二分查找普通实现。
     * @param srcArray 有序数组
     * @param key 查找元素
     * @return  不存在返回-1
     */
    public static int binSearch(int srcArray[], int key) {
        int mid;
        int start = 0;
        int end = srcArray.length - 1;
        while (start <= end) {
            mid = (end - start) / 2 + start;
            if (key < srcArray[mid]) {
                end = mid - 1;
            } else if (key > srcArray[mid]) {
                start = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}

```

## 算法分析

二分算法所操作的区间，是左闭右开，还是左闭右闭，需要在循环体跳出判断中，以及每次修改left,，right区间值这两个地方保持一致，否则就可能出错。

二分查找的平均查找长度 ASL 为 $((n+1)log_2(n+1))/n-1$，有的书上写的是 $log_2(n+1)-1$，或者是 $log_2n$，所以**二分查找算法的时间复杂度为O($log_2n$)**。

二分查找要求数列本身有序，所以在选择的时候需要确认数列是否本身有序，如果无序，则还需要进行排序，确认这样的代价是否符合实际需求。

其实我们在获取一个列表的很多时候，可以直接使用数据库针对某个字段进行排序，在程序中需要找出某个值的元素时，就很适合使用二分查找了。

二分查找适合元素稍微多一些的数列，如果元素只有十几或者几十个，则其实可以直接使用顺序查找（当然，也有人在顺序查找外面用了一个或几个大循环，执行这几层大循环需要计算机执行百万、千万遍，没有考虑到机器的性能）。

一般对于一个有序列表，如果只需要对其进行一次排序，之后不再变化或者很少变化，则每次进行二分查找的效率就会很高；但是如果在一个有序列表中频繁地插入、删除数据，那么维护这个有序列表会让人很累

## 参考

1. [Java实现的二分查找算法](https://my.oschina.net/u/2391658/blog/691399)
2. [https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/04.01.md](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/04.01.md)
3. [漫画：什么是二分查找算法](https://baijiahao.baidu.com/s?id=1635498997846582026&wfr=spider&for=pc)
4. [[算法总结] 二分查找](https://www.jianshu.com/p/0f823fbd4d20)
5. [二分查找（面试必备）](https://segmentfault.com/a/1190000008699980)
6. [二分查找（折半查找）算法（原理、实现及时间复杂度）](http://data.biancheng.net/view/122.html)
