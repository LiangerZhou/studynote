# 图的最短路径算法

## 1. 引言

  **最短路径问题**一直是图论研究的热点问题。例如在实际生活中的路径规划、地图导航等领域有重要的应用。关于求解图的最短路径方法也层出不穷，本篇文章将详细讲解图的最短路径经典算法。

## 2. 重要概念

**图的路径：** 图 G = 中，从任一顶点开始，由边或弧的邻接至关系构成的有限长顶点序列称为路径。  
*注意：有向图的路径必须沿弧的方向构成顶点序列；构成路径的顶点可能重复出现 (即允许反复绕圈)。*
**路径长度：** 路径中边或弧的数目。  
**简单路径：** 除第一个和最后一个顶点外，路径中无其它重复出现的顶点，称为简单路径。  
**回路或环：** 路径中的第一个顶点和最后一个顶点相同时，称为回路或环。  
**图的最短路径：** 如果从有向图中某一顶点 (称为源点) 到达另一顶点 (称为终点) 的路径可能不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小。

## 3. 深度或广度优先搜索算法

### 3.1 算法概述

  从起点开始访问所有深度遍历路径或广度优先路径，则到达终点节点的路径有多条，取其中路径权值最短的一条则为最短路径。

### 3.2 算法流程

（1）选择单源的起点作为遍历的起始点。  

（2）采用深度优先搜索或者广度优先搜索的方式遍历图，在遍历同时记录可以到达终点的路径。  

（3）在所有路径中选择距离最短的路径。

### 3.3 实例图解

例如：图 3.3.1 所示的有向图中，选取 A 为源点，D 为终点，采用遍历的方式获取最短路径。  

![图 3.3.1](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeIRa08DmmkuG8ictjn1iaIGe9hRS6R7NViamZ4bbh3LvmZY2Ng25FwZ8bB9c4gIPriaX3jgW3hwjPbJRwQ/640?wx_fmt=png)

（1）选择 A 为遍历起始点，D 为终点。

（2）采用遍历的方式获取 A 到 D 路径。通过遍历方式得到的路径共有 5 条。

（3）从中选择距离最短的路径为 A->B->D，长度为 9。

### 3.4 算法分析

  采用遍历的方式获取单源最短路径，是一种暴力破解的方式。算法的性能与遍历过程性能相关。采用深度优先搜索遍历时时间复杂度为 O(n+e)。

## 4. 迪杰斯特拉（Dijkstra）算法

### 4.1 算法概述

  Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算某个顶点到其他所有顶点的最短路径。Dijkstra（迪杰斯特拉）算法要求图中不存在负权边，即保证图中每条边的权重值为正。算法的基本思想是：从源点出发，每次选择离源点最近的一个顶点前进，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。

### 4.2 算法流程

- （1）将所有的顶点分为两部分：已知最短路程的顶点集合 P 和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P 中只有源点 s 一个顶点。我们这里用一个 book[i] 数组来记录哪些点在集合 P 中。例如对于某个顶点 i，如果 book[i] = 1 则表示这个顶点在集合 P 中，如果 book[i] = 0 则表示这个顶点在集合 Q 中。  
- （2）设置源点 s 到自己的最短路径为 0 即 dist = 0。若存在源点有能直接到达的顶点 i，则把 dist[i] 设为 e[s][i]。同时把所有其它（即源点不能直接到达的）顶点的最短路径为设为∞。  
- （3）在 Q 中选择一个离源点 s 最近的顶点 u（即 dist[u] 最小）加入到 P 中。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。  
- （4）重复第 3 步，如果集合 Q 为空，算法结束。最终 dist 数组中的值就是源点到所有顶点的最短路径。

### 4.3 实例图解

例如：图 4.3.1 所示的有向图，以顶点 1 为源点，运用 Dijkstra 算法，获得最短路径。  

![图 4.3.1](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeIRa08DmmkuG8ictjn1iaIGe9hKWgdlEOjSKrsPVB6elz0jNhm8EWomfXyCqsTdm0pdkluf4NdxiaoFlA/640?wx_fmt=png)

（1）初始状态下，集合 P 中只有顶点 1， book[1]=1。book 数组以及 dist 数组如图：

（2）从 dist 数组中可以看出，距离顶点 1 最近的顶点为 2，不存在可以中转的顶点使得顶点 1 到顶点 2 的距离更短，且顶点 2 不在集合 P 中。因此，选择顶点 2 加入集合 P 中，令 book[2]=1。顶点 2 加入后，需要考虑经过顶点 2 进行中转，使得顶点 1 到达其余顶点的距离发生改变。顶点 2 的出边有 < 2,3 > 和 < 2,4>。则需重新计算 dist[3] 和 dist[4]。dist[3] = dis[2]+e[2][3] = 10 < 12，令 dist[3] 松弛为 12。dist[4] = dis[2]+e[2][4] = 4 < INF，令 dist[4] 松弛为 4。更新后的 book 数组和 dist 数组如下：

（3）从剩余顶点 3、4、5、6 中选择 dist 中最近顶点为顶点 4（因为顶点 2 已经在集合 P 中不能再次选择）。将顶点 4 加入集合 P 中，令 book[4]=1。按照相同的方式更新 dist 数组。顶点 4 的所有出边 < 4,3>（dist[3] = dis[4]+e[4][3]），<4,5>（dist[5] = dis[4]+e[4][5]）和 < 4,6>（dist[6] = dis[4]+e[4][6]）用同样的方法进行松弛。松弛完毕之后 book 数组和 dist 数组为：

（4）继续在剩余的顶点 3、顶点 5 顶点和 6 中，选出离顶点 1 最近的顶点。选择 3 号顶点。此时，dis[3] 的值已对 3 号顶点的所有出边（3->5）（dist[5] = dis[3]+e[3][5]）进行松弛。松弛完毕之后 dist 数组为：

（5）继续在剩余的顶点 5 和顶点 6，选出离顶点 1 最近的顶点，选择 5 号顶点。对 5 号顶点的所有出边（5->4）（dist[4] = dis[5]+e[5][4]）进行松弛。松弛完毕之后 dist 数组为：

（6）最后选择顶点 6 加入集合 P，令 book[6]=1。由于 6 号顶点没有出边，因此不用进行松弛处理。最终得到的 dist 数组如下：

### 4.4 算法分析

**复杂度：** 迪杰斯特拉（Dijkstra）算法适用于权值为非负的图的单源最短路径，使用最小堆时间复杂度是 O(VLogV)，用斐波那契堆的复杂度 O(E+VlgV)。  
**为什么不能有负权边：** Dijkstra 算法当中将节点分为已求得最短路径的集合（记为 P）和未确定最短路径的个集合（记为 Q），归入 P 集合的节点的最短路径及其长度不再变更，如果边上的权值允许为负值，那么有可能出现当与 P 内某点（记为 a）以负边相连的点（记为 b）确定其最短路径时，它的最短路径长度加上这条负边的权值结果小于 a 原先确定的最短路径长度 (意思是原先从 a0---a 已经确定一个最短路径，而此时的边权值为负，则此步骤中的边权计算结果必定小于已经确定了的路径长度)，但是 a 在 Dijkstra 算法下是无法更新的，由此便可能得不到正确的结果。

## 5. 弗洛伊德（Floyd）算法

### 5.1 算法概述

  Floyd 算法是一个经典的动态规划算法。其主要思想为：从任意顶点 u 到任意顶点 v 的最短路径不外乎 2 种可能，一是直接从 u 到 v，二是从 u 经过若干个顶点 k 到 v。所以，我们假设 dist(u,v) 为顶点 u 到顶点 v 的最短路径的距离，对于每一个顶点 k，我们检查 dist(u,k) + dist(k,v) < dist(u,v) 是否成立，如果成立，证明从 u 到 k 再到 v 的路径比 u 直接到 v 的路径短，我们便设置 dist(u,v) = dist(u,k) + dist(k,v)，这样一来，当我们遍历完所有顶点 k，dist(u,v) 中记录的便是 u 到 v 的最短路径的距离。

### 5.2 算法流程

  （1）从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。
  （2）对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

### 5.3 实例图解

  例如：图 5.3.1 所示的有向图采用 Floyd 算法求解最短路径。选取顶点 1 为源点，顶点 3 为终点。  

![img](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeIRa08DmmkuG8ictjn1iaIGe9h9h8UM4swFaOukiafYdiaTW4OyF88iaia12MQib7eHcN3OxxgichuVoXnkINQ/640?wx_fmt=png)
  （1）选取单边路径为 <1,3>，由于顶点 1 与顶点 3 距离为 12。  
  （2）遍历剩余顶点 2、4、5、6，寻找是否有可以选做中间站的顶点，使得顶点 1 到顶点 3 路径小于 12。  
  （3）遍历完毕后，找到中间顶点 2。选择顶点 2 位中间顶点，使得因此顶点 1 到顶点 3 最短路径为 10。此时需要走的路径为（1,2），（2,3）。  
  （4）（1,2）边路径已经为最短路径，不存在中转顶点。遍历剩余顶点寻找（2,3）之间的中转顶点，发现通过顶点 4 可以使得 1->3 路径更短，路径长度为 7。以此类推，逐逐步寻找最短路径。  
  例如：图 5.3.1 所示的有向图采用 Floyd 算法求解最短路径。选取顶点 2 为源点，顶点 5 为终点。  
  （1）顶点 2 与顶点 5 不邻接，因此距离为 INF  
  （2）顶点 2 与顶点 5 可以通过顶点 3 中转，经过中转后距离为 14。此时路径为 2->3->5。  
  （3）顶点 2 到顶点 3 又可以通过顶点 4 中转，经过转后顶点 2 至顶点 5 距离为 12。此时路径为 2->4->3->5。

### 5.4 算法分析

  弗洛伊德（Floyd）算法的核心代码如下：

```java
for(int i = 1; i <= n; i++)//枚举所有顶点，i代表顶点u

{

    for(int j = 1; j <= n; j++)//枚举所有顶点，j代表顶点v

    {

        for(int k = 1; k <= n; k++)//查找是否有中间顶点w使得从u到w再到v比己知的路径更短

        {

            if(dist[j][k] > dist[j][i] + dist[i][k])

            {

                dist[j][k] = dist[j][i] + dist[i][k];

            }

        }

    }

}


```

  可以看出 Floyd 算法是一种暴力破解的方式获取最短路径。Floyd 算法的时间复杂度为 O(n^3)，空间复杂度为 O(n^2)。Floyd 算法可以获得任意顶点对之间的最短路径。

## 8. 结语

最短路径问题是图论研究中的一个经典算法问题。因此针对图最短路径问题先后提出了许多算法。各类算法的应用场景不尽相同。Dijkstra 算法和 Bellman-Ford 算法用于解决单源最短路径，而 Floyd 算法可以解决多源最短路径。  

- Dijkstra 算法适用稠密图（邻接矩阵），因为稠密图问题与顶点关系密切。
- Bellman-Ford 算法算法适用稀疏图（邻接表），因为稀疏图问题与边关系密切。
- Floyd 算法在稠密图（邻接矩阵）和稀疏图（邻接表）中都可以使用。

## 参考

1. [最短路径—Dijkstra算法和Floyd算法](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html)
2. [数据结构与算法——图最短路径](https://mp.weixin.qq.com/s?src=11&timestamp=1569422907&ver=1874&signature=8Vv9ODhHgsdsg5fy*QMWKr9oo2fjHMxF2y7hDJghXwzbcZAy30iil8iI1FUeDAq9*dWTVs44-IWkE4-MpxA*ygyrrJoDfubugjkGfAvxHKf6LA5JpV3ZQWLAEy7RsRPw&new=1)
