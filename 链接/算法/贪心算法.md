# 贪心算法

所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。

**所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。**

## 算法描述

### 基本思路

- 1、建立数学模型来描述问题。
- 2、把求解的问题分成若干个子问题。
- 3、对每一子问题求解，得到子问题的局部最优解。
- 4、把子问题的解局部最优解合成原来解问题的一个解。

### 性质

贪心算法的两个性质是贪心选择性质和最优子结构性质：

- 贪心选择性质：指所求的问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。

- 最优子结构（optimal substructure）性质：如果原问题的最优解包含的子问题的最优解，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“全局最优解包含局部最优解”的思想。

### 实现框架

实现框架

    从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    {
          利用可行的决策，求出可行解的一个解元素；
    }
    由所有解元素组合成问题的一个可行解；

## 代码实现

- 1、背包问题
  - 问题描述
  有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
  ![undefined](http://ww1.sinaimg.cn/large/bb854e66ly1g72lcriq0gj20cr036mxd.jpg)
  - 问题分析
    1.目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。
    2.约束条件：装入的物品总重量不超过背包容量：∑wi<=M( M=150)
    3.贪心策略：
    - 选择价值最大的物品
    - 选择价值最大的物品
    - 选择单位重量价值最大的物品

    有三个物品A,B,C，其重量分别为{30,10,20}，价值分别为{60,30,80}，背包的容量为50，分别应用三种贪心策略装入背包的物品和获得的价值如下图所示：
    ![undefined](http://ww1.sinaimg.cn/large/bb854e66ly1g72ldxnnpbj20e307f0sp.jpg)
    三种策略

  - 算法设计：
    - 计算出每个物品单位重量的价值
    - 按单位价值从大到小将物品排序
    - 根据背包当前所剩容量选取物品
    - 如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。

- 2、活动安排
  - 问题描述
  设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si < fi 。
  要求设计程序，使得安排的活动最多。
![undefined](http://ww1.sinaimg.cn/large/bb854e66ly1g72m30h0zmj20gq04f3yl.jpg)
(ps:活动结束时间按从小到大排序)

  - 问题分析：
    活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有n个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间starti和一个结束时间endi，且starti < endi。如选择了活动i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动i与活动j是相容的。也就是说，当startj≥endi或starti≥endj时，活动i与活动j相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。
    活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。
  - 算法设计：
    若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。

- 3、找零钱问题

  假设你开了间小店，不能电子支付，钱柜里的货币只有 25 分、10 分、5 分和 1 分四种硬币，如果你是售货员且要找给客户 41 分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？

  这里需要明确的几个点：
  - 1.货币只有 25 分、10 分、5 分和 1 分四种硬币；
  - 2.找给客户 41 分钱的硬币；
  - 3.硬币最少化

  思考，能使用我们今天学到的贪婪算法吗？怎么做？

    （回顾一下上文贪婪法的基本步骤，1，2，3）

  - 1.找给顾客sum_money=41分钱，可选择的是25 分、10 分、5 分和 1 分四种硬币。能找25分的，不找10分的原则，初次先找给顾客25分；
  - 2.还差顾客sum_money=41-25=16。然后从25 分、10 分、5 分和 1 分四种硬币选取局部最优的给顾客，也就是选10分的，此时sum_money=16-10=6。重复迭代过程，还需要sum_money=6-5=1,sum_money=1-1=0。至此，顾客收到零钱，交易结束；
  - 3.此时41分，分成了1个25，1个10，1个5，1个1，共四枚硬币。

- **4、Huffman编码**
- **5、最小生成树算法（Prim 算法 和 Kruskal 算法）**
- **6、启发式算法**

## 算法分析

贪心策略适用的前提是：**局部最优策略能导致产生全局最优解。**
实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。

### 算法特性

- 1、随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。
- 2、有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。
- 3、还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。
- 4、选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。
- 5、最后，目标函数给出解的值。
- 6、为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。

### 一般求解过程

使用贪心法求解能够依据下面几个方面进行（终于也相应着每步代码的实现），以找零钱为例：
　　
- 1、候选集合(C)
  通过一个候选集合C作为问题的可能解。（终于解均取自于候选集合C）
  比如。在找零钱问题中，各种面值的货币构成候选集合。　　
- 2、解集合(S)
  每完毕一次贪心选择，将一个解放入S。终于获得一个完整解S　　
- 3、解决函数(solution)
  检查解集合S是否构成问题的完整解。
  比如，在找零钱问题中。解决函数是已付出的货币金额恰好等于应付款。　　
- 4、选择函数(select)
  即贪心策略。这是贪心法的关键，选择出最有希望构成问题的解的对象。（这个选择函数通常和目标函数有关）   比如，在找零钱问题中，贪心策略就是在候选集合中选择面值最大的货币。　　
  5、可行函数(feasible)
  检查解集合中增加一个候选对象是否可行。（增加下一个对象后是不是满足约束条件）
  比如。在找零钱问题中，可行函数是每一步选择的货币和已付出的货币相加不超过应付款。

### 贪心算法与动态规划的区别

- 1、贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。
- 2、贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。
- 3、动态规划主要运用于二维或三维问题，而贪心一般是一维问题。

实际上，贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算。

尽管贪心算法和动态规划都有最优子结构性质，我认为这个性质在两种算法中有着不太一样的含义：贪心的局部最优能达成全局最优，而动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础。或者，我们可以认为，贪心算法通常都是自顶向下进行设计的，而动态规划则自底向上。

## 参考

1. [漫画：五分钟学会贪心算法](https://zhuanlan.zhihu.com/p/76164082)
2. [五大常用算法之三：贪心算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html)
3. [贪心算法详解](https://blog.csdn.net/effective_coder/article/details/8736718)
4. [从零开始学贪心算法](https://blog.csdn.net/qq_32400847/article/details/51336300)
5. [小白带你学---贪心算法（Greedy Algorithm)](https://zhuanlan.zhihu.com/p/53334049)
6. [贪心算法总结](https://www.jianshu.com/p/50f1d4e0555c)
7. [贪心算法](https://juejin.im/post/5aea722e6fb9a07ac652dbc8)
8. [中科大课件-贪心算法](http://staff.ustc.edu.cn/~lszhuang/alg/ch16.pdf)
9. [算法一篇通——贪心算法](https://kyonhuang.top/greedy-algorithm/)
10. [贪心算法](https://www.dreamxu.com/books/dsa/greedy/)
11. [贪心算法基本要素](https://sites.google.com/a/chaoskey.com/algorithm/04/02)
12. [贪心算法总结贪心算法基本思路算法实现实例分析参考](https://cloud.tencent.com/developer/article/1092766)
