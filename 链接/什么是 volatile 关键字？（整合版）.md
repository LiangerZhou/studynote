> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192450&idx=2&sn=ad95717051c0c4af83923b736a5bc637&chksm=8c99f3d8bbee7aceb123e4f6aa9a220630b5aa17743ba812d82308bfb6a8ed8303bdd181f144&scene=21#wechat_redirect

点击上方 “程序员小灰”，选择 “置顶公众号”

有趣有内涵的文章第一时间送达！

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfex11RJVO9t3xKTbwAcMBRBhbIXTicEErkO8mJeiaBZyBdyVhRIia9g73w/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfAky8UrdUzPqOPTOkWOyrbttQhS3e2u4fHQRZWiaosxJmxHrEh73dKjA/0?wx_fmt=jpeg)

**—————  第二天  —————**

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKt0RC8QnoOahl9MSGG01mQk35laaRwmIT4A8IWHnmFFy7vKNicXoJDGibA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKtSKFImWLnRGUNI1Ct4FRoC8ZsX0wflMBqEjJqFdof43317OiaGicydjkA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfup3Dq05t5gqiaKSUVuJ62ibD411LsHASPic3eauZA7JQibYoUvto0TUMJg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfLycoYoMX6Veb3uWsqRyRya3dFdDZYJHQYB7LucibLvJqG2gpSFVoIUQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfSk6ibSrHXicfoickKOL2R88O9fFYqWsM5UqvILYCLUD8o2P0Xjcic9h4WQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfavpz6w1fAlwKo0j9Uw4JuAAQNe3aNoobib26Z4Su37gDXdUNz5icdzGg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfJo8AaI51QbFdgAebBbBw2Sa5Yic8NBtbiaicOiaZaGiamaicx78XBbucIdpg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESflN5Ts1oyfiaHCHgbAZUrxGdpK8ZX27RAP8vOQV4DAPWMGxMX4lQqCbg/0?wx_fmt=jpeg)

————————————

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqxkFpyXIna0Fw7VUh9ib2qlLiaokKmL2tWuicYAcTJngQL5hcJX8r1AyT6J37Jqj9ckbBt6fx12DvFA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqxkFpyXIna0Fw7VUh9ib2qlsUrxsPDnk5cwnwshzsIdAUM0Kk6B3bZXXK4ROV1eEreU9Gly5VHa1g/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfWbS5Fe4eU4XiaFYCd4a8IUqGjFIDYMibjTywd9WwEWEic3w4dYwrtMvxA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfRYWbrMM4SY1Eq0eicBs7I2Xdyn3iaY79gCw1jNEBFqJfQ4ib3LwoNBDyA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoEYibomgkIaRUqPRZicHFESfg2ZtOiak0rem5c2J2cibl63icdNa3nutYI8F0Wb4ziaDyo1ibmmj6LQKdsw/0?wx_fmt=jpeg)

Java 内存模型简称 **JMM**（Java Memory Model），是 Java 虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，让 java 程序在各种平台下都能达到一致的内存访问效果。

Java 内存模型长成什么样子呢？就是下图的样子：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaoP0yvpTjvtYXECkp5GNib77GCbu7s5ticlhJ7wP6icxHRbgVLmhKj1vAg/0?wx_fmt=png)

这里需要解释几个概念：

**1. 主内存（Main Memory）**

主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的 “本尊”。

**2. 工作内存（Working Memory）**

工作内存可以简单理解为计算机当中的 CPU 高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的 “副本”。

线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaCVe7g4BJib7ubztkLEUeOanzgNibFTwUFwARmdKmGqgfE837v70c3xPg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGr3Rubo5VQoD4JGlnzqFtiamPCRYpRfUcJrJre8yvvhm36vPk1qxxFHG216TKmGMrSbRxgcHghLrPg/0?wx_fmt=jpeg)

以上说的这些可能有点抽象，大家来看看下面这个例子：

对于一个静态变量 

static int s = 0；

线程 A 执行如下代码：

s = 3；

那么，JMM 的工作流程如下图所示：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaRLzDhiarxQaibHzEPql6gNc7X4Uen9a1IFUibrcmT9F958w8AYZ9pWib4w/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaicW4Hu0O3ShT4xudm7Rz6qvBPlvBUTib5LnVS9dKSsqj7iciar6GMVZtiag/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaGotGF42YZR2rxszdN5wXpt54MibkUVlUjaLqcqkVPkn3cZnZHlwpZog/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaUgSYXNMqe4NHeLJkzOkhgqRobxAgRL6PzJLJgM6qxicSlVMqIzHg0Eg/0?wx_fmt=png)

通过一系列内存读写的操作指令（JVM 内存模型共定义了 8 种内存操作指令，以后会细讲），线程 A 把静态变量 s=0 从主内存读到工作内存，再把 s=3 的更新结果同步到主内存当中。从单线程的角度来看，这个过程没有任何问题。

这时候我们引入线程 B，执行如下代码：

System.out.println("s=" + s);

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaoPnssL56E8n52amhpZNe0hR6ZQ3Jk8X5Fibvxyiba4BLHZGN93YkWicSw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaibvukpDt7xXIM0CWkIaMIic1uuFTKtSB8tibVqsurBYacFJWEia6uHoreA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIianHyEkWdqFNk2eQGFpb0Jdc1OWqNsOPlDSUz4BV5TiadyAVdgvrvHMeA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaYJcOz8swZvZC0wA8F87XDjvcWwsq76jKSFfLYXAV8DoOMZ2EMiaAVmQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaibyHBfRPSnoUqpbBTSKiaZia3aZNrWKf07qc5Z6JDWkCwUeKtibAQic29PQ/0?wx_fmt=jpeg)

引入线程 B 以后，当线程 A 首先执行，更大的可能是出现下面情况：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaicW4Hu0O3ShT4xudm7Rz6qvBPlvBUTib5LnVS9dKSsqj7iciar6GMVZtiag/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaGotGF42YZR2rxszdN5wXpt54MibkUVlUjaLqcqkVPkn3cZnZHlwpZog/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaUgSYXNMqe4NHeLJkzOkhgqRobxAgRL6PzJLJgM6qxicSlVMqIzHg0Eg/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiayoDx1X2q8QLkagBVHhYOWNMlZldFaEg4UV9B4WibZf5Y4BheyGYibrsQ/0?wx_fmt=png)

此时线程 B 从主内存得到的 s 值是 3，理所当然输出 s=3，这种情况不难理解。但是，有较小的几率出现另一种情况：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaicW4Hu0O3ShT4xudm7Rz6qvBPlvBUTib5LnVS9dKSsqj7iciar6GMVZtiag/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaGotGF42YZR2rxszdN5wXpt54MibkUVlUjaLqcqkVPkn3cZnZHlwpZog/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiatmhYAzpxHZUhJttGx0ocqhSicGq49bBICj47E1aSwszuNH2VZqQZ97g/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaAY3DTOCrA2IIYQWMqLgjcoLBnbIUkk4BA38InkJN4fLpnpQw1PuO1g/0?wx_fmt=png)

因为工作内存所更新的变量并不会立即同步到主内存，所以虽然线程 A 在工作内存当中已经把变量 s 的值更新成 3，但是线程 B 从主内存得到的变量 s 的值仍然是 0，从而输出 s=0。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaiak6lctMTzmSWe8XEpbksFmUEzGDl4QiaHVLOaVYZ9icpE87DkuydhtuA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiacdvfENBsO3mTwp44KfGv1KM2ia6jW6ZXXocFbrQpgxOl6WUI15qqwsg/0?wx_fmt=jpeg)

volatile 关键字具有许多特性，其中最重要的特性就是保证了用 volatile 修饰的变量对所有线程的**可见性**。  

这里的可见性是什么意思呢？当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。

为什么 volatile 关键字可以有这样的特性？这得益于 java 语言的**先行发生原则**（happens-before）。先行发生原则在维基百科上的定义如下：

In computer science, the happened-before relation is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow). 

翻译结果如下：

在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。

这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。  

先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。我们这里只列举出 volatile 相关的规则：

对于一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

回到上述的代码例子，如果在静态变量 s 之前加上 volatile 修饰符：

volatile static int s = 0；

线程 A 执行如下代码：

s = 3；

这时候我们引入线程 B，执行如下代码：

System.out.println("s=" + s);

当线程 A 先执行的时候，把 s = 3 写入主内存的事件必定会先于读取 s 的事件。所以线程 B 的输出一定是 s = 3。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiahuycJz7EEVNiaribl7UC7Rnjb2PnU90XictUVA1JRQW5lskkJaVesT4ng/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiacGHtWWvn4YoM7m2S9tgbrrOrZK8VjmCNtwI2utpRYjOZbPfTQKhZfA/0?wx_fmt=jpeg)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiajmics7iawMN88Pvc8f0ibksibZsxqaia4FDEkFV2HexZmcUoBuD8Vr5icDwg/0?wx_fmt=png)

这段代码是什么意思呢？很简单，开启 10 个线程，每个线程当中让静态变量 count 自增 100 次。执行之后会发现，最终 count 的结果值未必是 1000，有可能**小于 1000**。  

使用 volatile 修饰的变量，为什么并发自增的时候会出现这样的问题呢？这是因为 count++ 这一行代码本身并不是原子性操作，在字节码层面可以拆分成如下指令：

getstatic        // 读取静态变量（count）

iconst_1        // 定义常量 1

iadd               //count 增加 1

putstatic        // 把 count 结果同步到主内存

虽然每一次执行 getstatic 的时候，获取到的都是主内存的最新变量值，但是进行 iadd 的时候，由于并不是原子性操作，其他线程在这过程中很可能让 count 自增了很多次。这样一来本线程所计算更新的是一个陈旧的 count 值，自然无法做到线程安全：

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIia3XQgiaHrSFjI796vHa2HibawLJXZIjp4Yy4Y5o7drOCUuWqtz1xJhLiag/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaIxwDHiaswQxJiakPKNmBibDuvTnCdn7zoM3optwTjN6qjI9QawXaP5TTg/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIia1ibH2m3NXrGtnvSydNVdWeTRibJqZ3yS0DmJkCWGB0q34BhxjSN7G5sw/0?wx_fmt=png)

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIian9g7mYTHTQ8k39QoTnRBet1fEOic1IJC1Jfgg0swXlahVea20URqSJw/0?wx_fmt=png)

因此，什么时候适合用 volatile 呢？

**1. 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。**

**2. 变量不需要与其他的状态变量共同参与不变约束。**

第一条很好理解，就是上面的代码例子。第二条是什么意思呢？可以看看下面这个场景：

volatile static int start = 3;

volatile static int end = 6;

线程 A 执行如下代码：

while (start < end){

  //do something

}

线程 B 执行如下代码：

start+=3;

end+=3;

这种情况下，一旦在线程 A 的循环中执行了线程 B，start 有可能先更新成 6，造成了一瞬间 start == end，从而跳出 while 循环的可能性。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGricHmm50IzXNiaAMroheficIiaaraOG7fC6FN8G6kEqLbXiccVnCDu8qhFwkXctNqAH52j2f9tDeMUWSg/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGr52DkKTvibZ66NoqEsogD6kdD91qgBM9ia4KQforeBA7uTXRR5dzeXUgoias0502eN1GpcUNNHju0DQ/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGr52DkKTvibZ66NoqEsogD6kTclGdUOh1FknZtvmaY45icM4jXFP7Lozl0CNDYQCrwjTUueibGnto4yA/0?wx_fmt=jpeg)

**什么是指令重排？**

指令重排是指 JVM 在编译 Java 代码的时候，或者 CPU 在执行 JVM 字节码的时候，对现有的指令顺序进行重新排序。

指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。

然而，指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。我们来看看下面的例子：

boolean contextReady = false;

在线程 A 中执行:

context = loadContext();

contextReady = true;

在线程 B 中执行:

while(! contextReady){ 

   sleep(200);

}

doAfterContextReady (context);

  
以上程序看似没有问题。线程 B 循环等待上下文 context 的加载，一旦 context 加载完成，contextReady == true 的时候，才执行 doAfterContextReady 方法。

但是，如果线程 A 执行的代码发生了指令重排，初始化和 contextReady 的赋值交换了顺序：

boolean contextReady = false;

在线程 A 中执行:

**contextReady = true;**

**context = loadContext();**

在线程 B 中执行:

while(! contextReady){ 

   sleep(200);

}

doAfterContextReady (context);

这个时候，很可能 context 对象还没有加载完成，变量 contextReady 已经为 true，线程 B 直接跳出了循环等待，开始执行 doAfterContextReady 方法，结果自然会出现错误。  

需要注意的是，这里 java 代码的重排只是为了简单示意，真正的指令重排是在字节码指令的层面。  

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNofLrwcnlhqCSZW9rKB3KFbRqlVrI31sKY3SpLubFB7LUeKevAIA5Mw/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNmEGBz4KRF2auicv7gN5Bw9lu9mZ36bKeYSBWfycSDtLO6mYI3LZj5ZA/0?wx_fmt=jpeg)

****什么是内存屏障？****

内存屏障（Memory Barrier）是一种 CPU 指令，维基百科给出了如下定义：

A memory barrier, also known as a membar, memory fence or fence instruction, is a type of barrier instruction that causes a CPU or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

翻译结果如下：

内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。

内存屏障共分为四种类型：

**LoadLoad 屏障**：

抽象场景：Load1; LoadLoad; Load2

Load1 和 Load2 代表两条读取指令。在 Load2 要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。

**StoreStore 屏障：**

抽象场景：Store1; StoreStore; Store2

Store1 和 Store2 代表两条写入指令。在 Store2 写入执行前，保证 Store1 的写入操作对其它处理器可见

**LoadStore 屏障：**

抽象场景：Load1; LoadStore; Store2

在 Store2 被写入前，保证 Load1 要读取的数据被读取完毕。

**StoreLoad 屏障：**

抽象场景：Store1; StoreLoad; Load2

在 Load2 读取操作执行前，保证 Store1 的写入对所有处理器可见。StoreLoad 屏障的开销是四种屏障中最大的。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNSmTVvBUtV92YdEWh6zV28KyV2b379pj2H9b9wXomib5pFHn3hwap2XA/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZN0uGNzwIQGrqVyn49Hl3y00W5F2ILurmic1BiaZEU4c6uvHeFaf6XiaXYQ/0?wx_fmt=jpeg)

****volatile 做了什么？  
****

在一个变量被 volatile 修饰后，JVM 会为我们做两件事：

1. 在每个 volatile 写操作前插入 **StoreStore** 屏障，在写操作后插入 **StoreLoad** 屏障。

2. 在每个 volatile 读操作前插入 **LoadLoad** 屏障，在读操作后插入 **LoadStore** 屏障。

或许这样说有些抽象，我们看一看刚才线程 A 代码的例子：

boolean contextReady = false;

在线程 A 中执行:

context = loadContext();

contextReady = true;

我们给 contextReady 增加 volatile 修饰符，会带来什么效果呢？

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNgbHjhxmckhPrUjTic5QiaXz7ZQPxcK7VeCJBnXnelicXdV2icqYpMnkqrQ/0?wx_fmt=png)

由于加入了 StoreStore 屏障，屏障上方的普通写入语句 context = loadContext()  和屏障下方的 volatile 写入语句 contextReady = true 无法交换顺序，从而成功阻止了指令重排序。

![](http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNYovZib1bfhKYia7BXPRJVQEtYCvAsHHwBOj1eAV6tMVDhHhiaJ5bI7JRQ/0?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNfYiaycibq23e0IwbAh0Xglc0duWibGvZQXlegice8ftfPYiapdapPOCJG2A/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNdcurbWA1szuyZ9e5CO5OznJkpaoXWWqPOdTgHPLVCYFGSauGbYX10g/0?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZNgPic2ib8SgknT3nSF67tw7Qn7ib8IOewoIwAIAchsAoF2FoiamMev2pLVQ/0?wx_fmt=jpeg)

**volatile 特性之一：**

保证变量在线程之间的可见性。可见性的保证是基于 CPU 的内存屏障指令，被 JSR-133 抽象为 happens-before 原则。

**volatile 特性之二：**

阻止编译时和运行时的指令重排。编译时 JVM 编译器遵循内存屏障的约束，运行时依靠 CPU 屏障指令来阻止重排。

![](https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrWpvrPRUMd9kgMU1fQSxZN0Dkw70TGBV93eAfo9zJiaahFntcbv7GCskIHrvPr9f76IHFvu3zTSkg/0?wx_fmt=jpeg)

**几点补充：**

1. 关于 volatile 的介绍，本文很多内容来自《深入理解 Java 虚拟机》这本书。有兴趣的同学可以去看看。

2. 在使用 volatile 引入内存屏障的时候，普通读、普通写、volatile 读、volatile 写会排列组合出许多不同的场景。我们这里只简单列出了其中一种，有兴趣的同学可以查资料进一步学习其他阻止指令重排的场景。

3.volatile 除了保证可见性和阻止指令重排，还解决了 long 类型和 double 类型数据的 **8 字节赋值问题**。这个特性相对简单，本文就不详细描述了。

4. **本漫画纯属娱乐，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。**

—————END—————

喜欢本文的朋友们，欢迎长按下图关注订阅号**程序员小灰**，收看更多精彩内容

![](http://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoBj18gILw2hefgpNaCia1eRhNCzRx29e1DpVhicyenCic4RQibDTbzySoqqpOrmBxu7KlLZM73YDDPJg/0?wx_fmt=jpeg)