# Java 垃圾回收机制

## 一、垃圾回收机制的意义

　　Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有 “作用域” 的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

　　ps: 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。

## 二、垃圾回收机制中的算法

　　Java 语言规范没有明确地说明 JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做 2 件基本的事情：

- （1）发现无用信息对象；

- （2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。　　

### 1. 引用计数法 (Reference Counting Collector)

1.1 算法分析

　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为 1。当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b, 则 b 引用的对象实例的计数器 + 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。任何引用计数器为 0 的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减 1。

1.2 优缺点

优点：

　　引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点：

　　无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为 0.

1.3 引用计数算法无法解决循环引用问题，例如：

```java
public class Main {
    public static void main(String[] args) {
        MyObject object1 = new MyObject();
        MyObject object2 = new MyObject();

        object1.object = object2;
        object2.object = object1;

        object1 = null;
        object2 = null;
    }
}
```

　　最后面两句将 object1 和 object2 赋值为 null，也就是说 object1 和 object2 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。

### 2. tracing 算法 (Tracing Collector) 或 标记 - 清除算法 (mark and sweep)

2.1 根搜索算法

![根搜索算法](https://images0.cnblogs.com/blog2015/694841/201506/141050566294022.jpg)

　　根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

java 中可作为 GC Root 的对象有

　　1. 虚拟机栈中引用的对象（本地变量表）

　　2. 方法区中静态属性引用的对象

　　3. 方法区中常量引用的对象

　　4. 本地方法栈中引用的对象（Native 对象）

2.2 tracing 算法的示意图

![tracing](https://images0.cnblogs.com/blog2015/694841/201506/141048430359736.jpg)

2.3 标记 - 清除算法分析

　　标记 - 清除算法采用从根集合进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记 - 清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记 - 清除算法直接回收不存活的对象，因此会造成内存碎片。

### 3. compacting 算法 或 标记 - 整理算法

![compacting 算法](https://images0.cnblogs.com/blog2015/694841/201506/141120037076681.jpg)

 　　标记 - 整理算法采用标记 - 清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记 - 整理算法是在标记 - 清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于 Compacting 算法的收集器的实现中，一般增加句柄和句柄表。

### 4. copying 算法 (Copying Collector)

![copying 算法](https://images0.cnblogs.com/blog2015/694841/201506/141112115351233.jpg)

　　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于 copying 算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面 (使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于 coping 算法的垃圾回收是 stop-and-copy 算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。
它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。

主要缺点：内存缩小为原来的一半

### 5. generation 算法 (Generational Collector)

![generation 算法](https://images0.cnblogs.com/blog2015/694841/201506/141332429573819.jpg)

　　分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。

- 年轻代（Young Generation）

　　1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

　　2. 新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。一个 Eden 区，两个 Survivor 区 (一般而言)。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。

　　3. 当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收

　　4. 新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高 (不一定等 Eden 区满了才触发)

- 年老代（Old Generation）

　　1. 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

　　2. 内存比新生代也大很多 (大概比例是 1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。

- 持久代（Permanent Generation）

　　用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

## 三. GC（垃圾收集器）

新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge

老年代收集器使用的收集器：Serial Old、Parallel Old、CMS

![垃圾收集](https://images0.cnblogs.com/blog2015/694841/201506/141513122384006.jpg)

- **Serial 收集器（复制算法)**

　　新生代单线程收集器，标记和清理都是单线程，优点是简单高效。

- **Serial Old 收集器 (标记 - 整理算法)**

　　老年代单线程收集器，Serial 收集器的老年代版本。

- **ParNew 收集器 (停止 - 复制算法)**

　　新生代收集器，可以认为是 Serial 收集器的多线程版本, 在多核 CPU 环境下有着比 Serial 更好的表现。

- **Parallel Scavenge 收集器 (停止 - 复制算法)**

　　并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量 = 用户线程时间 /(用户线程时间 + GC 线程时间)。适合后台应用等对交互相应要求不高的场景。

- **Parallel Old 收集器 (停止 - 复制算法)**

　　Parallel Scavenge 收集器的老年代版本，并行收集器，吞吐量优先

- **CMS(Concurrent Mark Sweep) 收集器（标记 - 清理算法）**

　　高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择

## 四、GC 的执行机制

　　由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC 有两种类型：Scavenge GC 和 Full GC。

- **Scavenge GC**

    一般情况下，当新对象生成，并且在 Eden 申请空间失败时，就会触发 Scavenge GC，对 Eden 区域进行 GC，清除非存活对象，并且把尚且存活的对象移动到 Survivor 区。然后整理 Survivor 的两个区。这种方式的 GC 是对年轻代的 Eden 区进行，不会影响到年老代。因为大部分对象都是从 Eden 区开始的，同时 Eden 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使 Eden 去能尽快空闲出来。

- **Full GC**

    对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比 Scavenge GC 要慢，因此应该尽可能减少 Full GC 的次数。在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节。有如下原因可能导致 Full GC：

　　1. 年老代（Tenured）被写满

　　2. 持久代（Perm）被写满

　　3. System.gc() 被显示调用

　　4. 上一次 GC 之后 Heap 的各域分配策略动态变化

## 五、Java 有了 GC 同样会出现内存泄露问题

- 静态集合类像 HashMap、Vector 等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等应用着。

```java
Static Vector v = new Vector();
for (int i = 1; i<100; i++)
{
    Object o = new Object();
    v.add(o);
    o = null;
}
```

　　在这个例子中，代码栈中存在 Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管 o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。

- 各种连接，数据库连接，网络连接，IO 连接等没有显示调用 close 关闭，不被 GC 回收导致内存泄露。

- 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。
