> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://mp.weixin.qq.com/s/__PS_NEKdsm8BAXGOKFFkw

**1. 内存模型以及分区，需要详细到每个区放什么。**

JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，

class 类信息常量池（static 常量和 static 变量）等放在方法区

new:

方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字

节码）等数据

堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要

在堆上分配

栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操

作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所

以还是一个指向地址的指针

本地方法栈：主要为 Native 方法服务

程序计数器：记录当前线程执行的行号

**2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。**

堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包

含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复

制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动

到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区

当新生区满了之后会触发 YGC, 先把存活的对象放到其中一个 Survice

区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎

片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，

就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，

就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存

活时间一般比较久远。

**3. 对象创建方法，对象的内存分配，对象的访问定位。**

new 一个对象

**4. GC 的两种判定方法：**

引用计数法：指的是如果某个地方引用了这个对象就 + 1，如果失效了就 - 1，当为 0 就

会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）

的情况

引用链法：通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等 - static 变

量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明

可以回收

**5. SafePoint 是什么**

比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始

执行 GC，

1. 循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入

safepoint)

2. 方法返回前

3. 调用方法的 call 之后

4. 抛出异常的位置

![](https://mmbiz.qpic.cn/mmbiz_png/2LlmEpiamhyoG1h9UicuhnGbKBox7icUibSJ57icibTXrt6muPVHLnWtcDrao9ickOTZyCib1zib5RojtbmQTGibHUxKqXnA/640?wx_fmt=png)

**6. GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？**

先标记，标记完毕之后再清除，效率不高，会产生碎片

复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC

标记整理：标记完毕之后，让所有存活的对象向一端移动

**7. GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。**

并行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间

串行收集器：次要回收中使用多线程来执行

CMS 收集器是基于 “标记— 清除” 算法实现的，经过多次标记才会被清除

G1 从 整体来看是基于 “标记— 整理” 算法实现的收集器，从 局部（两个 Region 之间）

上来看是基于 “复制” 算法实现的

**8. Minor GC 与 Full GC 分别在什么时候发生？**

新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC

**9. 几种常用的内存调试工具：jmap、jstack、jconsole、jhat**

jstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息

mat（eclipse 的也要了解一下）

**10. 类加载的几个过程：**

加载、验证、准备、解析、初始化。然后是使用和卸载了

通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文

件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符

号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码

![](https://mmbiz.qpic.cn/mmbiz_png/2LlmEpiamhyoG1h9UicuhnGbKBox7icUibSJRtW3G6FF2jwIj2VFzHT7UAgWpceKTHZwx8Ve0VzKBK8kJWW5br2NAQ/640?wx_fmt=png)

**1. 数据库三范式是什么?**

1. 第一范式（1NF）：字段具有原子性, 不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)

2. 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。

3. 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 

> 所以第三范式具有如下特征：

>>1. 每一列只有一个值 

>>2. 每一行都能区分。 

>>3. 每一个表都不包含其他表已经包含的非主关键字信息。

**2. 有哪些数据库优化方面的经验?**

1. 用 PreparedStatement， 一般来说比 Statement 性能高：一个 sql

发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。

2. 有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，

那在设计数据库时就去掉外键。

3. 表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等

4. UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用 UNIONALL。>>UNION 和 UNION ALL 关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。>1. 对重复结果的处理：UNION 在进行表链接后会筛选掉重复的记录，Union All 不会去除重复记录。>2. 对排序的处理：Union 将会按照字段的顺序进行排序；UNION ALL 只是简单的将两个结果合并后就返回。

**3. 请简述常用的索引有哪些种类?**

1. 普通索引: 即针对数据库表创建索引

2. 唯一索引: 与普通索引类似，不同的就是：MySQL 数据库索引列的值必须唯一，但允许有空值

3. 主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引

4. 组合索引: 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。

**4. 以及在 mysql 数据库中索引的工作机制是什么？**

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更

新数据库表中数据。索引的实现通常使用 B 树及其变种 B + 树

**5.MySQL 的基础操作命令:**

1. MySQL 是否处于运行状态: Debian 上运行命令 service mysqlstatus，在 RedHat 上运行命令 service mysqld status

2. 开启或停止 MySQL 服务 : 运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务

3. Shell 登入 MySQL: 运行命令 mysql -u root -p

4. 列出所有数据库: 运行命令 show databases;

5. 切换到某个数据库并在上面工作: 运行命令 use databasename; 进入名为 databasename 的数据库

6. 列出某个数据库内所有表: show tables;

7. 获取表内所有 Field 对象的名称和类型 :describe table_name;

![](https://mmbiz.qpic.cn/mmbiz_png/2LlmEpiamhyoG1h9UicuhnGbKBox7icUibSJSNJxh3R3TdIYF2h9Ojuia4iaepV27CibaZOv54C9py60VagjpLWLalvRQ/640?wx_fmt=png)

**6.mysql 的复制原理以及流程。**

Mysql 内建的复制功能是构建大型，高性能应用程序的基础。将 Mysql 的数据分布到多个系统上去，这种分布的机制，是通过将 Mysql 的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。* 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。过程如下 1. 主服务器把更新记录到二进制日志文件中。2. 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。3. 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。

**7.mysql 支持的复制类型?**

1. 基于语句的复制：在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。MySQL 默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。

2. 基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从 mysql5.0 开始支持

3. 混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。

**8.mysql 中 中 varchar 与 与 char 的区别以及 varchar(50) 中的 50 代表的涵义？**

1. varchar 与 char 的区别: char 是一种固定长度的类型，varchar 则是一种可变长度的类型.

2. varchar(50) 中 50 的涵义 : 最多存放 50 个字节

3. int（20）中 20 的涵义: int(M) 中的 M indicates the maximumdisplay width (最大显示宽度)for integer types. The maximumlegal display width is 255.

**9. 表中有大字段 X （例如：text 类型），且字段 X 不会经常更新，以读为为主，将该字段拆成子表好处是什么？**

如果字段里面有大字段（text,blob) 类型的，而且这些字段的访问并不多，这

时候放在一起就变成缺点了。MYSQL 数据库的记录存储是按行存储的，数据

块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此

时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需

要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，

对字段的 UPDAE 就要 UPDATE 多个表了

**10.MySQL 中 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？**

InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与

Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这

种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级

锁，否则，InnoDB 将使用表锁！